REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。

Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。

Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。

## 第1章　引言

本书对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，力图展示这些功能的核心数据结构以及关键的算法思想。

通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，这些知识可以帮助读者更好地、也更高效地使用Redis。

## 第2章 简单动态字符串

- Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。
- 在Redis里面，C字符串只会作为字符串字面量（string literal）用在一些无须对字符串值进行修改的地方，比如打印日志

### SDS的定义

结构体定义：

```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串（二进制安全）
    char buf[];
};
```

SDS示例：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwoeir658jj30qc0cewey.jpg)

- free属性的值为0，表示这个SDS没有分配任何未使用空间。

- len属性的值为5，表示这个SDS保存了一个五字节长的字符串。

- buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，而最后一个字节则保存了空字符'\0'。

  - SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。

    > printf("%s", s->buf);

### SDS与C字符串的区别

- 根据传统，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符'\0'。
- C字符串并不能满足Redis对字符串在安全性、效率以及功能方面的要求，接下来详细对比C字符串与SDS的区别，以及为什么redis要选用SDS

#### 常数复杂度获取字符串长度

- 因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。
- 和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）

#### 杜绝缓冲区溢出 

- 除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）

  > 举个例子，<string.h>/strcat函数可以将src字符串中的内容拼接到dest字符串的末尾：
  >
  > ------
  >
  > > ```c
  > > char *strcat(char *dest, const char *src);
  > > ```
  >
  > ------
  >
  > 因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。

- 与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

  > 举个例子，SDS的API里面也有一个用于执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够，如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作。
  >
  > 例如，如果我们执行：
  >
  > ------
  >
  > > ```c
  > > sdscat(s, " Cluster");
  > > ```
  >
  > ------
  >
  > 那么sdscat将在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接"Cluster"之后，sdscat就会先扩展s的空间，然后才执行拼接"Cluster"的操作。
  >
  > 注意到free也分配了13字节，正好等于len，这与SDS的空间分配策略有关。
  >
  > ![](https://tva1.sinaimg.cn/large/008i3skNly1gwoepwd1noj318g0pwq52.jpg)

#### 减少修改字符串时带来的内存重分配次数

- 正如前两个小节所说，因为C字符串并不记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：
  	- 如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。
  	- 如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。

- 因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，所以SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录

- 通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

  1. 空间预分配

     空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。额外分配的未使用空间数量由以下公式决定：

     - 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。

       > 举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。

     - 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。

       >  举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。

  2. 惰性空间释放

     惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用

#### 二进制安全

- C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据
- 为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。

- SDS使用len属性的值而不是空字符来判断字符串是否结束

#### 兼容部分C字符串函数

- 虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分<string.h>库定义的函数。

![image-20211124005859769](/Users/zhenheng.lhl/Library/Application Support/typora-user-images/image-20211124005859769.png)

![image-20211124005911487](/Users/zhenheng.lhl/Library/Application Support/typora-user-images/image-20211124005911487.png)

##  第3章 链表

- 作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。
- 链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表

### 链表和链表节点的实现

- 每个链表节点使用一个adlist.h/listNode结构来表示，多个listNode可以通过prev和next指针组成双端链表：

------

> ```c
> typedef struct listNode {
>     // 前置节点
>     struct listNode * prev;
>     // 后置节点
>     struct listNode * next;
>     // 节点的值
>     void * value;
> }listNode;
> 
> ```

------

- 虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：

  ```c
  
  typedef struct list {
      // 表头节点
      listNode * head;
      // 表尾节点
      listNode * tail;
      // 链表所包含的节点数量
      unsigned long len;
      // 节点值复制函数
      void *(*dup)(void *ptr);
      // 节点值释放函数
      void (*free)(void *ptr);
      // 节点值对比函数
      int (*match)(void *ptr,void *key);
  } list;
  ```

![image-20211123010216567](https://tva1.sinaimg.cn/large/008i3skNgy1gwof6q0ueoj318c0j8gnl.jpg)

- Redis的链表实现的特性可以总结如下：

  - 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。

  - 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。

  - 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。

  - 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。

  - 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

![image-20211124005822460](https://tva1.sinaimg.cn/large/008i3skNly1gwpkoyldflj30vm0a60u6.jpg)

![image-20211124005832662](https://tva1.sinaimg.cn/large/008i3skNly1gwpkp501yyj30vq0f240c.jpg)

## 第4章　字典

- 字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。

- 字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。

  > 举个例子，当我们执行命令：
  >
  > ------
  >
  > > ```shell
  > > redis> SET msg "hello world"
  > > OK
  > > ```
  >
  > ------
  >
  > 在数据库中创建一个键为"msg"，值为"hello world"的键值对时，这个键值对就是保存在代表数据库的字典里面的。

### 字典的实现

- Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 哈希表

- Redis字典所使用的哈希表由dict.h/dictht结构定义：

------

> ```c
> typedef struct dictht {
>     // 哈希表数组
>     dictEntry **table;
>     // 哈希表大小
>     unsigned long size;
>     //哈希表大小掩码，用于计算索引值
>     //总是等于size-1
>     unsigned long sizemask;
>     // 该哈希表已有节点的数量
>     unsigned long used;
> } dictht;signed long used;} dictht;
> ```

------

- table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。

![image-20211128152852616](https://tva1.sinaimg.cn/large/008i3skNly1gwuwby1iv4j310n0u076k.jpg)

#### 哈希表节点

- 哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

------

> ```c
> 
> typedef struct dictEntry {
>     // 键
>     void *key;
>     // 值
>     union{
>         void *val;
>         uint64_tu64;
>         int64_ts64;
>     } v;
>     // 指向下个哈希表节点，形成链表
>     struct dictEntry *next;
> } dictEntry;
> ```

------

- key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。
- next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

#### 字典

- Redis中的字典由dict.h/dict结构表示：

  ```c
  typedef struct dict {
      // 类型特定函数
      dictType *type;
      // 私有数据
      void *privdata;
      // 哈希表
      dictht ht[2];
      // rehash索引
      // 当rehash不在进行时，值为-1
      int rehashidx; /* rehashing not in progress if rehashidx == -1 */
  } dict;
  ```

- type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：

  - type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。

  - 而privdata属性则保存了需要传给那些类型特定函数的可选参数。

  ------

  > ```c
  > typedef struct dictType {
  >     // 计算哈希值的函数
  >     unsigned int (*hashFunction)(const void *key);
  >     // 复制键的函数
  >     void *(*keyDup)(void *privdata, const void *key);
  >     // 复制值的函数
  >     void *(*valDup)(void *privdata, const void *obj);
  >     // 对比键的函数
  >     int (*keyCompare)(void *privdata, const void *key1, const void *key2);
  >     // 销毁键的函数
  >     void (*keyDestructor)(void *privdata, void *key);
  >     // 销毁值的函数
  >     void (*valDestructor)(void *privdata, void *obj);
  > } dictType;
  > ```

- ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

- 除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。

### 哈希算法

- 当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

- Redis计算哈希值和索引值的方法如下：

------

> ```c
> #使用字典设置的哈希函数，计算键key的哈希值
> hash = dict->type->hashFunction(key);
> #使用哈希表的sizemask属性和哈希值，计算出索引值
> #根据情况不同，ht[x]可以是ht[0]或者ht[1]
> index = hash & dict->ht[x].sizemask;
> 
> ```

- 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。MurmurHash算法目前的最新版本为MurmurHash3，而Redis使用的是MurmurHash2

### 解决键冲突

- 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。

- Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。
- 因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O（1）），排在其他已有节点的前面

### rehash

- 随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

- 扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：
  1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：
     - 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方幂）；
     - 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。
  2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
  3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

#### 哈希表的扩展与收缩

- 当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：
  - 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
  - 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

- 其中哈希表的负载因子可以通过公式：

```shell
# 负载因子=哈希表已保存节点数量/哈希表大小
load_factor = ht[0].used / ht[0].size
```

>  在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。

- 另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

### 渐进式rehash

- 上一节说过，扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。这是为了避免rehash对服务器性能造成影响
- 以下是哈希表渐进式rehash的详细步骤：
  1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
  2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
  3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
  4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。
- 渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

#### 渐进式rehash执行期间的哈希表操作

- 因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。
- 另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。

![image-20211124005711467](https://tva1.sinaimg.cn/large/008i3skNly1gwpknq4owpj30vi08mq3s.jpg)

![image-20211124005723147](https://tva1.sinaimg.cn/large/008i3skNly1gwpknxcu0gj30vi04saag.jpg)

## 第5章　跳跃表

- 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

- 跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

- 在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。

- Redis使用跳跃表作为**有序集合键**的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。

- 和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。

### 跳跃表的实现

- Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。

![image-20211123014840161](https://tva1.sinaimg.cn/large/008i3skNly1gwogizjqbxj318m0kqjtz.jpg)

- 位于图片最左边的是zskiplist结构，该结构包含以下属性：
  - header：指向跳跃表的表头节点。
  - tail：指向跳跃表的表尾节点。
  - level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。
  - length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

- 位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：
  	- 层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。
  	- 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。
  	- 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。
  	- 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。

#### 跳跃表节点

跳跃表节点的实现由redis.h/zskiplistNode结构定义：

------

> ```c
> typedef struct zskiplistNode {
>     // 层
>     struct zskiplistLevel {
>         // 前进指针
>         struct zskiplistNode *forward;
>         // 跨度
>         unsigned int span;
>     } level[];
>     // 后退指针
>     struct zskiplistNode *backward;
>     // 分值
>     double score;
>     // 成员对象
>     robj *obj;
> } zskiplistNode;
> ```

1. 层

​	跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。

​	每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。

2. 前进指针

​	每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点

3. 跨度

​	层的跨度（level[i].span属性）用于记录两个节点之间的距离：

	- 两个节点之间的跨度越大，它们相距得就越远。

- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。

>  初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。

4. 后退指针

​	节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。

5. 分值和成员

​	节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。

​	节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。

>  在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。

#### 跳跃表

- 使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量

- zskiplist结构的定义如下：

------

> ```c
> typedef struct zskiplist {
>     // 表头节点和表尾节点
>     structz skiplistNode *header, *tail;
>     // 表中节点的数量
>     unsigned long length;
>     // 表中层数最大的节点的层数
>     int level;
> } zskiplist;
> ```

- header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O（1）。

- 通过使用length属性来记录节点的数量，程序可以在O（1）复杂度内返回跳跃表的长度。

- level属性则用于在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。

![image-20211124005621964](https://tva1.sinaimg.cn/large/008i3skNly1gwpkmvbymwj30vm0jotb8.jpg)

![image-20211124005641668](https://tva1.sinaimg.cn/large/008i3skNly1gwpkn7ea7ij30vg06oq3q.jpg)

## 第6章　整数集合

- 整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

- 每个intset.h/intset结构表示一个整数集合：

------

> ```c
> typedef struct intset {
>     // 编码方式
>     uint32_t encoding;
>     // 集合包含的元素数量
>     uint32_t length;
>     // 保存元素的数组
>     int8_t contents[];
> } intset;
> ```

------

- contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。
- length属性记录了整数集合包含的元素数量，也即是contents数组的长度。
- 虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：

  - 如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767）。
  - 如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647）。
  - 如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。

![image-20211128152927657](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwckqvcmj30z00dwt9w.jpg)

### 升级

- 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。

- 升级整数集合并添加新元素共分为三步进行：

  	1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
  	1. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。
  	1. 将新元素添加到底层数组里面。

  > 最后将encoding属性升级，再增加length属性

#### 升级之后新元素的摆放位置

- 因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：

  		- 在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；
  	
  		- 在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。

### 升级的好处

- 提升灵活性

  因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以通过升级来适应新元素，非常灵活

- 节约内存

  如果有使用场景需要将int16_t、int32_t、int64_t同时保存到一个数组中，最直接想到的应该int64_t[]数组存储所有元素，但如果使用场景中int16_t元素很多，int16_t元素装进int64_t[]，会浪费很多内存空间。

  通过升级能在只有int16_t的时候只用int16_t[]，节省了内存

### 降级（不支持）

- 整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

![image-20211124005538110](https://tva1.sinaimg.cn/large/008i3skNly1gwpkm5kazkj30vg09mq49.jpg)

## 第7章　压缩列表

- 压缩列表（ziplist）是列表键和哈希键的底层实现之一。
  - 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
  - 另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

### 压缩列表的构成

- 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

![image-20211124010511321](/Users/zhenheng.lhl/Library/Application Support/typora-user-images/image-20211124010511321.png)

### 压缩列表节点的构成

- 每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成

#### previous_entry_length

- 节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。
- previous_entry_length属性的长度可以是1字节或者5字节：
  	- 如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。
  	- 如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。

- 可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。

>  压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。

#### encoding

- 节点的encoding属性记录了节点的content属性所保存数据的类型以及长度

#### content

- 节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。

### 连锁更新

- 因为previous_entry_length有可能是1字节有可能是5字节，当插入一个大于254字节的新元素到压缩列表头前时，如果之前的头元素（现在为压缩列表插入后第二个元素）的previous_entry_length为1字节，这时无法满足，需要扩展到5字节，第二个元素的扩展很可能引起第三个元素的扩展，以此类推。
- Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）。删除节点也可能会引发连锁更新。

![image-20211124011745004](https://tva1.sinaimg.cn/large/008i3skNgy1gwpl94o37uj30vi0u0gox.jpg)

- 因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N 2）。

- 要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：
  - 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；
  - 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；

- 因为以上原因，ziplistPush等命令的平均复杂度仅为O（N），在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。

![image-20211124011836840](https://tva1.sinaimg.cn/large/008i3skNgy1gwpla0kpqfj30vg0k4acx.jpg)

## 第8章　对象

- Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。
- 使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。
- 除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

### 对象的类型与编码

- 每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。

- 以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值"msg"的对象，而键值对的值则是一个包含了字符串值"hello world"的对象：

  ```shell
  
  redis> SET msg "hello world"
  OK
  ```

- Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：

  ------

  > ```c
  > typedef struct redisObject {
  >     // 类型
  >     unsigned type:4;
  >     // 编码
  >     unsigned encoding:4;
  >     // 指向底层实现数据结构的指针
  >     void *ptr;
  >     // ...
  > } robj;
  > ```

#### 类型

- 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种
- 当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型

```shell
# 键为字符串对象，值为字符串对象
redis> SET msg "hello world"
OK
redis> TYPE msg
string
# 键为字符串对象，值为列表对象
redis> RPUSH numbers 1 3 5
(integer) 6
redis> TYPE numbers
list
# 键为字符串对象，值为哈希对象
redis> HMSET profile name Tom age 25 career Programmer
OK
redis> TYPE profile
hash
# 键为字符串对象，值为集合对象
redis> SADD fruits apple banana cherry
(integer) 3
redis> TYPE fruits
set
# 键为字符串对象，值为有序集合对象
redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
redis> TYPE price
zset
```

#### 编码和底层实现

- 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。
- encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现

![image-20211127212734011](https://tva1.sinaimg.cn/large/008i3skNly1gwu18zods7j318m0jcdij.jpg)

- 每种类型的对象都至少使用了两种不同的编码，如

![image-20211127213412708](https://tva1.sinaimg.cn/large/008i3skNly1gwu19rl3u8j318m0qun27.jpg)

>  使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码

- 通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

> 举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：
>
> - 因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；
>
> - 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；

### 字符串对象

- 字符串对象的编码可以是int、raw或者embstr。

  - 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。

  - 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。ptr属性指向这个sdshdr

  - 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。

    > embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，如图8-3所示。
    >
    > ![image-20211127221219781](https://tva1.sinaimg.cn/large/008i3skNly1gwu2df46f3j314006g754.jpg)

#### 编码的转换

- int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。

#### 字符串命令的实现

- 因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的

![image-20211128150925335](https://tva1.sinaimg.cn/large/008i3skNly1gwuvrprg4qj312z0u0dl6.jpg)

![image-20211128150948904](https://tva1.sinaimg.cn/large/008i3skNly1gwuvs45lcpj318i0p0jvh.jpg)

### 列表对象

- 列表对象的编码可以是ziplist或者linkedlist。举个例子：

```shell

redis> RPUSH numbers 1 "three" 5
(integer) 3
```

![image-20211128234033526](https://tva1.sinaimg.cn/large/008i3skNgy1gwvajjmbljj310o0dg3ze.jpg)

![image-20211128234050687](https://tva1.sinaimg.cn/large/008i3skNgy1gwvaju3t5uj310i0e4404.jpg)

#### 编码转换

- 只有当满足下面两个条件，列表对象才能用ziplist编码，否则只能用linkedlist

  - 列表对象保存的所有字符串元素的长度都小于64字节；

  - 列表对象保存的元素数量小于512个；

#### 列表命令的实现

- 因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建

![image-20211128152131166](https://tva1.sinaimg.cn/large/008i3skNly1gwuw4aln9nj30u016etfb.jpg)

### 哈希对象

- 哈希对象的编码可以是ziplist或者hashtable。

- ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：
  - 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
  - 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

- 举例：

  ```shell
  (integer) 1
  redis> HSET profile age 25
  (integer) 1
  redis> HSET profile career "Programmer"
  (integer) 1
  
  ```

  ![image-20211128152410661](https://tva1.sinaimg.cn/large/008i3skNly1gwuw721c0zj319m0owacv.jpg)

- 另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
  - 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
  - 字典的每个值都是一个字符串对象，对象中保存了键值对的值。

​	![image-20211128152455297](https://tva1.sinaimg.cn/large/008i3skNly1gwuw7u0xw7j31120p8go4.jpg)

#### 编码转换

- 只有满足下面两个条件时，哈希对象才能使用ziplist编码，否则要用hashtable编码：

  	- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
  	
  	- 哈希对象保存的键值对数量小于512个；

#### 哈希命令的实现

- 因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的

![image-20211128153021624](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwdj0hxuj30x40u0wj7.jpg)

### 集合对象

- 集合对象的编码可以是intset或者hashtable。

- intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

  ```shell
  redis> SADD numbers 1 3 5
  (integer) 3
  
  ```

- 另一方面，hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

  ```shell
  redis> SAD Dfruits "apple" "banana" "cherry"
  (integer)3
  ```

  ![image-20211128153305172](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwgbvh8cj310y0tqn0s.jpg)

#### 编码的转换

- 只有当满足下面两个条件时，集合对象才使用intset编码，否则就要用hashtable编码：

  - 集合对象保存的所有元素都是整数值；

  - 集合对象保存的元素数量不超过512个。

#### 集合命令的实现

- 因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的

![image-20211128153424483](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwhpnd0zj318o07o0tt.jpg)

![image-20211128153433447](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwhuu7axj311k0u0wjt.jpg)

### 有序集合对象

- 有序集合的编码可以是ziplist或者skiplist。

- ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。

  - 压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

    ```shell
    redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
    (integer) 3
    ```

- skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

------

> ```c
> typedef struct zset {
>     zskiplist *zsl;
>     dict *dict;
> } zset;
> 
> ```

![image-20211128154004730](https://tva1.sinaimg.cn/large/008i3skNly1gwuwnlmdb6j318w08sdh7.jpg)

- zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。

- 除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。

- 值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以**同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值**，也不会因此而浪费额外的内存。

> 为什么有序集合需要同时使用跳跃表和字典来实现？
>
> 如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。
>
> 另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合

- 举个例子，如果前面price键创建的不是ziplist编码的有序集合对象，而是skiplist编码的有序集合对象，那么这个有序集合对象将会是图8-16所示的样子，而对象所使用的zset结构将会是图8-17所示的样子。

![image-20211128154421064](https://tva1.sinaimg.cn/large/008i3skNly1gwuws2fds7j30u016r42i.jpg)

> 为了展示方便，图8-17在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存。

#### 编码的转换

- 只有当下面两个条件都满足时，有序列表对象才能使用ziplist编码，否则要用skiplist编码：
  - 有序集合保存的元素数量小于128个；
  - 有序集合保存的所有元素成员的长度都小于64字节；

#### 有序集合命令的实现

- 因为有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的

![image-20211128154600999](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwtsf04sj30u0109wjv.jpg)

### 类型检查与命令多态

- Redis中用于操作键的命令基本上可以分为两种类型。

- 其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。

  ```shell
  
  # 字符串键
  redis> SET msg "hello"
  OK
  # 列表键
  redis> RPUSH numbers 1 2 3
  (integer) 3
  # 集合键
  redis> SADD fruits apple banana cherry
  (integer) 3
  redis> DEL msg
  (integer) 1
  redis> DEL numbers
  (integer) 1
  redis> DEL fruits
  (integer) 1
  ```

  

- 而另一种命令只能对特定类型的键执行，比如说：

  - SET、GET、APPEND、STRLEN等命令只能对字符串键执行；

  - HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；

  - RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；

  - SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；

  - ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；

#### 类型检查的实现

- 类型检查是通过redisObject结构的type属性来实现的

> 举个例子，对于LLEN命令来说：
>
> - 在执行LLEN命令之前，服务器会先检查输入数据库键的值对象是否为列表类型，也即是，检查值对象redisObject结构type属性的值是否为REDIS_LIST，如果是的话，服务器就对键执行LLEN命令；
>
> - 否则的话，服务器就拒绝执行命令并向客户端返回一个类型错误；

#### 多态命令的实现

- Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。借用面向对象方面的术语来说，我们可以认为LLEN命令是多态（polymorphism）的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行。

- 如果我们对一个键执行LLEN命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令实现：

  - 如果列表对象的编码为ziplist，那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表的长度；

  - 如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度；

### 内存回收

- 因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

- 每个对象的引用计数信息由redisObject结构的refcount属性记录：

------

> ```c
> 
> typedef struct redisObject {
>     // ...
>     // 引用计数
>     int refcount;
>     // ...
> } robj;
> ```

------

- 对象的引用计数信息会随着对象的使用状态而不断变化：
  - 在创建一个新对象时，引用计数的值会被初始化为1；
  - 当对象被一个新程序使用时，它的引用计数值会被增一；
  - 当对象不再被一个程序使用时，它的引用计数值会被减一；
  - 当对象的引用计数值变为0时，对象所占用的内存会被释放。

![image-20211128230849093](https://tva1.sinaimg.cn/large/008i3skNgy1gwv9mjn3bgj318e0aign3.jpg)

> 使用OBJECT REFCOUNT命令查看键A的值对象的引用计数

### 对象共享

- 除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用

- 在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

  1）将数据库键的值指针指向一个现有的值对象；

  2）将被共享的值对象的引用计数增一。

- 尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享

  > 当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：
  > - 如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）；
  > - 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；
  > - 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N 2）。

### 对象的空转时长

- redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间

  > OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的（这个命令在访问键的值对象时，不会修改值对象的lru属性）

## 第9章　数据库

### 服务器中的数据库

- Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库，在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：

------

> ```c
> struct redisServer {
>     // ...
>     // 一个数组，保存着服务器中的所有数据库
>     redisDb *db;
>     // ...
>   	// 服务器的数据库数量
>     int dbnum;
>   	// ...
>   	// 数据库键空间，保存着数据库中的所有键值对
>     dict *dict;
>      // 过期字典，保存着键的过期时间
>     dict *expires;
> };
> 
> ```

------

- dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16

### 切换数据库

- 每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。

- 默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。

- 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针，指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库：

------

> ```c
> typedef struct redisClient {
> // ...
> // 记录客户端当前正在使用的数据库
> redisDb *db;
> // ...
> } redisClient;
> 
> ```

------

> 有些客户端不会显示目标数据库的号码，那可能会在多次切换后忘记自己，所以最好在执行危险命令前（如FLUSHDB清空整个数据库）执行一个SELECT命令

### 数据库键空间

- Redis是一个键值对（key-value pair）数据库服务器，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：

  ```c
  typedef struct redisDb {
      // ...
      // 数据库键空间，保存着数据库中的所有键值对
      dict *dict;
      // ...
  } redisDb;
  
  ```

  

- 键空间和用户所见的数据库是直接对应的：

  - 键空间的键也就是数据库的键，每个键都是一个字符串对象。
  - 键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。

- 举例：

  ```shell
  redis> SET message "hello world"
  OK
  redis> RPUSH alphabet "a" "b" "c"
  (integer)3
  redis> HSET book name "Redis in Action"
  (integer) 1
  redis> HSET book author "Josiah L. Carlson"
  (integer) 1
  redis> HSET book publisher "Manning"
  (integer) 1
  
  ```

![image-20211128234302333](https://tva1.sinaimg.cn/large/008i3skNly1gwvam44oxaj315v0u0dj1.jpg)

#### 增删改查

- 添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。

- 删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。
- 对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。

- 对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象

```shell

redis> SET date "2013.12.1"
OK
redis> DEL book
(integer) 1
redis> SET message "blah blah" # 键message的值对象将从之前包含"hello world"字符串更新为包含"blah blah"字符串
OK
redis> HSET book page 320
(integer) 1
redis> GET message
"hello world"
redis> LRANGE alphabet 0 -1
1)"a"
2)"b"
3)"c"

```

#### 其他键空间操作

- 比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。

- 另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。

#### 读写键空间时的维护操作

- 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数

  >  这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。

- 在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间

  >  使用OBJECT idletime命令可以查看键key的闲置时间。

- 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作

- 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过

- 服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作

- 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知

### 设置键的生存时间或过期时间

- 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：

  ```shell
  redis> SET key value
  OK
  redis> EXPIRE key 5
  (integer) 1
  redis> GET key  // 5
  秒之内
  "value"
  redis> GET key  // 5
  秒之后
  (nil)
  ```

  > SETEX命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令（只能用于字符串键）

- 与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键：

  ```shell
  redis> SET key value
  OK
  redis> EXPIREAT key 1377257300
  (integer) 1
  redis> TIME
  1)"1377257296"
  2)"296543"
  redis> GET key    // 1377257300
  之前
  "value"
  redis> TIME
  1)"1377257303"
  2)"230656"
  redis> GET key    // 1377257300
  之后
  (nil)
  ```

  

> TTL命令（秒）和PTTL命令（毫秒）接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间

#### 设置过期时间

- Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：

  ```shell
  ·EXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl秒。
  
  ·PEXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl毫秒。
  
  ·EXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
  
  ·PEXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。
  ```

- 实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：

#### 保存过期时间

- redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：
  - 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。
  - 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

#### 移除过期时间

- PERSIST命令可以移除一个键的过期时间：在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联

### 过期键删除策略

- 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。

- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。

- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

#### 定时删除

- 对内存最友好：可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存
- 对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间
- 除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件
- 因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。

#### 惰性删除

- 对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。
- 缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。

- redis非常依赖于内存，大量过期键没有被访问也就无法删除（除非用户手动FLUSHDB），甚至可以看成内存泄露。对于有些数据如日志，访问量大大减少，而造成redis服务器内存紧张

#### 定期删除

- 定期删除策略是前两种策略的一种整合和折中：
  - 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
  - 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。
-  难点是确定删除操作执行的时长和频率：
  - 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。
  - 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。

### Redis的过期键删除策略

- Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。

#### 惰性删除策略的实现

- 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查

- expireIfNeeded函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键。
- 因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况

#### 定期删除策略的实现

- 过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。工作过程如下：
  - 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
  - 全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。
  - 随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。

- 伪代码：

```python
# 默认每次检查的数据库数量
DEFAULT_DB_NUMBERS = 16
# 默认每个数据库检查的键数量
DEFAULT_KEY_NUMBERS = 20
# 全局变量，记录检查进度
current_db = 0
def activeExpireCycle():
    # 初始化要检查的数据库数量
    # 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 
要小
    # 那么以服务器的数据库数量为准
    if server.dbnum < DEFAULT_DB_NUMBERS:
        db_numbers = server.dbnum
    else:
        db_numbers = DEFAULT_DB_NUMBERS
    # 遍历各个数据库
    for i in range(db_numbers):
        # 如果current_db的值等于服务器的数据库数量
        # 这表示检查程序已经遍历了服务器的所有数据库一次
        # 将current_db重置为0，开始新的一轮遍历
        if current_db == server.dbnum:
            current_db = 0
        # 获取当前要处理的数据库
        redisDb = server.db[current_db]
        # 将数据库索引增1，指向下一个要处理的数据库
        current_db += 1
        # 检查数据库键
        for j in range(DEFAULT_KEY_NUMBERS):
            # 如果数据库中没有一个键带有过期时间，那么跳过这个数据库
            if redisDb.expires.size() == 0: break
            # 随机获取一个带有过期时间的键
            key_with_ttl = redisDb.expires.get_random_key()
            # 检查键是否过期，如果过期就删除它
            if is_expired(key_with_ttl):
                delete_key(key_with_ttl)
            # 已达到时间上限，停止处理
            if reach_time_limit(): return
```

### AOF、RDB和复制功能对过期键的处理

> Redis 持久化之RDB和AOF：https://www.cnblogs.com/itdragon/p/7906481.html

#### 生成RDB文件

- 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

#### 载入RDB文件

- 在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
  - 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
  - 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

#### AOF文件写入（AppendOnly File）

- 当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

- 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

#### AOF重写

- 和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。
- 因此，数据库中包含过期键不会对AOF重写造成影响。

#### 复制

- 当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：
  - 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。	
  - 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。
  - 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。

- 通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。

  > 如果从服务器接收到过期键的get请求，仍然返回键的值，就好像这个键没过期一样。
  >
  > 只有当主服务器删除这个过期键，并且向从服务器发送了DEL命令，从服务器才会把过期键删除
  >
  > 从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性

#### 数据库通知

- 数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。

- 关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification）

  ```shell
  
  # 获取0号数据库中针对message键执行的所有命令
  127.0.0.1:6379> SUBSCRIBE _ _keyspace@0_ _:message
  Reading messages... (press Ctrl-C to quit)
  1) "subscribe"  // 订阅信息
  2) "__keyspace@0__:message"     
  3) (integer) 1  
  1) "message"    //执行SET命令
  2) "_ _keyspace@0_ _:message"   
  3) "set"        
  1) "message"    //执行EXPIRE命令
  2) "_ _keyspace@0_ _:message"   
  3) "expire"     
  1) "message"    //执行DEL命令
  2) "_ _keyspace@0_ _:message"   
  3) "del"     
  ```

- 键事件通知（key-event notification）的通知,关注的是“某个命令被什么键执行了”

  ```shell
  # 获取0号数据库中所有执行DEL命令的键
  127.0.0.1:6379> SUBSCRIBE _ _keyevent@0_ _:del
  Reading messages... (press Ctrl-C to quit)
  1) "subscribe"  // 订阅信息
  2) "_ _keyevent@0_ _:del"
  3) (integer) 1
  1) "message"    //键key执行了DEL命令
  2) "_ _keyevent@0_ _:del"
  3) "key"
  1) "message"    //键number执行了DEL命令
  2) "_ _keyevent@0_ _:del"
  3) "number"
  1) "message"    //键message执行了DEL命令
  2) "_ _keyevent@0_ _:del"
  3) "message"
  ```


## RDB持久化

- 因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。
- 为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。

- RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态

### RDB文件的创建与载入

- 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。

- SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
- BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求

- RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。

#### BGSAVE命令执行时的服务器状态

- 在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。

- 其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。

- 最后，出于性能考虑，BGREWRITEAOF和BGSAVE两个命令不能同时执行（后来的命令延迟到前者执行完毕后再执行）

#### RDB文件载入时的服务器状态

- 服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止

### 自动间隔性保存

- 因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。

- 保存条件由saveparams数组维护：

  ```c
  struct redisServer {
      // ...
      // 记录了保存条件的数组
      struct saveparam *saveparams;
      // ...
  };
  struct saveparam {
      // 秒数
      time_t seconds;
      // 修改数
      int changes;
  };
  
  
  ```

  ```shell
  save 900 1 # 服务器在900秒之内，对数据库进行了至少1次修改。对应saveparam结构体
  save 300 10
  save 60 10000
  ```

  

#### dirty&lastsave

- dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。
- lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

```c
struct redisServer {
    // ...
    // 修改计数器
    long long dirty;
    // 上一次执行保存的时间
    time_t lastsave;
    // ...
};
```

#### 检查保存条件是否满足

- Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

- 遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令

### RDB文件结构

![image-20211130011112017](https://tva1.sinaimg.cn/large/008i3skNgy1gwwis7bpo2j310s04u0t7.jpg)