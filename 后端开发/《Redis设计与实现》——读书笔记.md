REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。

Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。

Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。

## 第1章　引言

本书对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，力图展示这些功能的核心数据结构以及关键的算法思想。

通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，这些知识可以帮助读者更好地、也更高效地使用Redis。

## 第2章 简单动态字符串

- Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。
- 在Redis里面，C字符串只会作为字符串字面量（string literal）用在一些无须对字符串值进行修改的地方，比如打印日志

### SDS的定义

结构体定义：

```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串（二进制安全）
    char buf[];
};
```

SDS示例：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwoeir658jj30qc0cewey.jpg)

- free属性的值为0，表示这个SDS没有分配任何未使用空间。

- len属性的值为5，表示这个SDS保存了一个五字节长的字符串。

- buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，而最后一个字节则保存了空字符'\0'。

  - SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。

    > printf("%s", s->buf);

- Redis5.0 SDS数据结构

![image-20211209100447798](https://tva1.sinaimg.cn/large/008i3skNly1gx7cs52yytj310c0qqtaj.jpg)

- flags有5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5 种类型的主要区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同。比如sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，sdshdr32 则都是 uint32_t。这是为了能灵活保存不同⼤⼩的字符串，从⽽有效节省内存空间

  ```c
  struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];
  };
  // __attribute__ ((__packed__))：告诉编译器取消结构体在编译过程中的优化对⻬，按照实际占⽤字节数进⾏对⻬
  ```

  

### SDS与C字符串的区别

- 根据传统，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符'\0'。
- C字符串并不能满足Redis对字符串在安全性、效率以及功能方面的要求，接下来详细对比C字符串与SDS的区别，以及为什么redis要选用SDS

#### 常数复杂度获取字符串长度

- 因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。
- 和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）

#### 杜绝缓冲区溢出 

- 除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）

  > 举个例子，<string.h>/strcat函数可以将src字符串中的内容拼接到dest字符串的末尾：
  >
  > ------
  >
  > > ```c
  > > char *strcat(char *dest, const char *src);
  > > ```
  >
  > ------
  >
  > 因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。

- 与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

  > 举个例子，SDS的API里面也有一个用于执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够，如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作。
  >
  > 例如，如果我们执行：
  >
  > ------
  >
  > > ```c
  > > sdscat(s, " Cluster");
  > > ```
  >
  > ------
  >
  > 那么sdscat将在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接"Cluster"之后，sdscat就会先扩展s的空间，然后才执行拼接"Cluster"的操作。
  >
  > 注意到free也分配了13字节，正好等于len，这与SDS的空间分配策略有关。
  >
  > ![](https://tva1.sinaimg.cn/large/008i3skNly1gwoepwd1noj318g0pwq52.jpg)

#### 减少修改字符串时带来的内存重分配次数

- 正如前两个小节所说，因为C字符串并不记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：
  	- 如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。
  	- 如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。

- 因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，所以SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录

- 通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

  1. 空间预分配

     空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。额外分配的未使用空间数量由以下公式决定：

     - 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。

       > 举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。

     - 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。

       >  举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。

  2. 惰性空间释放

     惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用

#### 二进制安全

- C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据
- 为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。

- SDS使用len属性的值而不是空字符来判断字符串是否结束

#### 兼容部分C字符串函数

- 虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分<string.h>库定义的函数。

![image-20211124005859769](/Users/zhenheng.lhl/Library/Application Support/typora-user-images/image-20211124005859769.png)

![image-20211124005911487](/Users/zhenheng.lhl/Library/Application Support/typora-user-images/image-20211124005911487.png)

##  第3章 链表

- 作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。
- 链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表

### 链表和链表节点的实现

- 每个链表节点使用一个adlist.h/listNode结构来表示，多个listNode可以通过prev和next指针组成双端链表：

------

> ```c
> typedef struct listNode {
>     // 前置节点
>     struct listNode * prev;
>     // 后置节点
>     struct listNode * next;
>     // 节点的值
>     void * value;
> }listNode;
> 
> ```

------

- 虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：

  ```c
  
  typedef struct list {
      // 表头节点
      listNode * head;
      // 表尾节点
      listNode * tail;
      // 链表所包含的节点数量
      unsigned long len;
      // 节点值复制函数
      void *(*dup)(void *ptr);
      // 节点值释放函数
      void (*free)(void *ptr);
      // 节点值对比函数
      int (*match)(void *ptr,void *key);
  } list;
  ```

![image-20211123010216567](https://tva1.sinaimg.cn/large/008i3skNgy1gwof6q0ueoj318c0j8gnl.jpg)

- Redis的链表实现的特性可以总结如下：

  - 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。

  - 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。

  - 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。

  - 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。

  - 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

![image-20211124005822460](https://tva1.sinaimg.cn/large/008i3skNly1gwpkoyldflj30vm0a60u6.jpg)

![image-20211124005832662](https://tva1.sinaimg.cn/large/008i3skNly1gwpkp501yyj30vq0f240c.jpg)

## 第4章 字典

- 字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。

- 字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。

  > 举个例子，当我们执行命令：
  >
  > ------
  >
  > > ```shell
  > > redis> SET msg "hello world"
  > > OK
  > > ```
  >
  > ------
  >
  > 在数据库中创建一个键为"msg"，值为"hello world"的键值对时，这个键值对就是保存在代表数据库的字典里面的。

### 字典的实现

- Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 哈希表

- Redis字典所使用的哈希表由dict.h/dictht结构定义：

------

> ```c
> typedef struct dictht {
>     // 哈希表数组
>     dictEntry **table;
>     // 哈希表大小
>     unsigned long size;
>     //哈希表大小掩码，用于计算索引值
>     //总是等于size-1
>     unsigned long sizemask;
>     // 该哈希表已有节点的数量
>     unsigned long used;
> } dictht;signed long used;} dictht;
> ```

------

- table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。

![image-20211128152852616](https://tva1.sinaimg.cn/large/008i3skNly1gwuwby1iv4j310n0u076k.jpg)

#### 哈希表节点

- 哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

------

> ```c
> 
> typedef struct dictEntry {
>     // 键
>     void *key;
>     // 值
>     union{
>         void *val;
>         uint64_tu64;
>         int64_ts64;
>     } v;
>     // 指向下个哈希表节点，形成链表
>     struct dictEntry *next;
> } dictEntry;
> ```

------

- key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。
- next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

#### 字典

- Redis中的字典由dict.h/dict结构表示：

  ```c
  typedef struct dict {
      // 类型特定函数
      dictType *type;
      // 私有数据
      void *privdata;
      // 哈希表
      dictht ht[2];
      // rehash索引
      // 当rehash不在进行时，值为-1
      int rehashidx; /* rehashing not in progress if rehashidx == -1 */
  } dict;
  ```

- type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：

  - type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。

  - 而privdata属性则保存了需要传给那些类型特定函数的可选参数。

  ------

  > ```c
  > typedef struct dictType {
  >     // 计算哈希值的函数
  >     unsigned int (*hashFunction)(const void *key);
  >     // 复制键的函数
  >     void *(*keyDup)(void *privdata, const void *key);
  >     // 复制值的函数
  >     void *(*valDup)(void *privdata, const void *obj);
  >     // 对比键的函数
  >     int (*keyCompare)(void *privdata, const void *key1, const void *key2);
  >     // 销毁键的函数
  >     void (*keyDestructor)(void *privdata, void *key);
  >     // 销毁值的函数
  >     void (*valDestructor)(void *privdata, void *obj);
  > } dictType;
  > ```

- ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

- 除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。

### 哈希算法

- 当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

- Redis计算哈希值和索引值的方法如下：

------

> ```c
> #使用字典设置的哈希函数，计算键key的哈希值
> hash = dict->type->hashFunction(key);
> #使用哈希表的sizemask属性和哈希值，计算出索引值
> #根据情况不同，ht[x]可以是ht[0]或者ht[1]
> index = hash & dict->ht[x].sizemask;
> 
> ```

- 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。MurmurHash算法目前的最新版本为MurmurHash3，而Redis使用的是MurmurHash2

### 解决键冲突

- 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。

- Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。
- 因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O（1）），排在其他已有节点的前面

### rehash

- 随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

- 扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：
  1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：
     - 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方幂）；
     - 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。
  2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
  3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

#### 哈希表的扩展与收缩

- 当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：
  - 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
  - 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

- 其中哈希表的负载因子可以通过公式：

```shell
# 负载因子=哈希表已保存节点数量/哈希表大小
load_factor = ht[0].used / ht[0].size
```

>  在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。

- 另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

### 渐进式rehash

- 上一节说过，扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。这是为了避免rehash对服务器性能造成影响
- 以下是哈希表渐进式rehash的详细步骤：
  1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
  2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
  3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
  4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。
- 渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

#### 渐进式rehash执行期间的哈希表操作

- 因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。
- 另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。

![image-20211124005711467](https://tva1.sinaimg.cn/large/008i3skNly1gwpknq4owpj30vi08mq3s.jpg)

![image-20211124005723147](https://tva1.sinaimg.cn/large/008i3skNly1gwpknxcu0gj30vi04saag.jpg)

## 第5章　跳跃表

- 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

- 跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

- 在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。

- Redis使用跳跃表作为**有序集合键**的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。

- 和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。

### 跳跃表的实现

- Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。

![image-20211123014840161](https://tva1.sinaimg.cn/large/008i3skNly1gwogizjqbxj318m0kqjtz.jpg)

- 位于图片最左边的是zskiplist结构，该结构包含以下属性：
  - header：指向跳跃表的表头节点。
  - tail：指向跳跃表的表尾节点。
  - level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。
  - length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

- 位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：
  	- 层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。
  	- 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。
  	- 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。
  	- 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。

#### 跳跃表节点

跳跃表节点的实现由redis.h/zskiplistNode结构定义：

------

> ```c
> typedef struct zskiplistNode {
>     // 层
>     struct zskiplistLevel {
>         // 前进指针
>         struct zskiplistNode *forward;
>         // 跨度
>         unsigned int span;
>     } level[];
>     // 后退指针
>     struct zskiplistNode *backward;
>     // 分值
>     double score;
>     // 成员对象
>     robj *obj;
> } zskiplistNode;
> ```

1. 层

​	跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。

​	每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。

2. 前进指针

​	每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点

3. 跨度

​	层的跨度（level[i].span属性）用于记录两个节点之间的距离：

	- 两个节点之间的跨度越大，它们相距得就越远。

- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。

>  初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。

4. 后退指针

​	节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。

5. 分值和成员

​	节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。

​	节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。

>  在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。

#### 跳跃表

- 使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量

- zskiplist结构的定义如下：

------

> ```c
> typedef struct zskiplist {
>     // 表头节点和表尾节点
>     structz skiplistNode *header, *tail;
>     // 表中节点的数量
>     unsigned long length;
>     // 表中层数最大的节点的层数
>     int level;
> } zskiplist;
> ```

- header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O（1）。

- 通过使用length属性来记录节点的数量，程序可以在O（1）复杂度内返回跳跃表的长度。

- level属性则用于在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。

![image-20211124005621964](https://tva1.sinaimg.cn/large/008i3skNly1gwpkmvbymwj30vm0jotb8.jpg)

![image-20211124005641668](https://tva1.sinaimg.cn/large/008i3skNly1gwpkn7ea7ij30vg06oq3q.jpg)

## 第6章　整数集合

- 整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

- 每个intset.h/intset结构表示一个整数集合：

------

> ```c
> typedef struct intset {
>     // 编码方式
>     uint32_t encoding;
>     // 集合包含的元素数量
>     uint32_t length;
>     // 保存元素的数组
>     int8_t contents[];
> } intset;
> ```

------

- contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。
- length属性记录了整数集合包含的元素数量，也即是contents数组的长度。
- 虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：

  - 如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767）。
  - 如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647）。
  - 如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。

![image-20211128152927657](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwckqvcmj30z00dwt9w.jpg)

### 升级

- 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。

- 升级整数集合并添加新元素共分为三步进行：

  	1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
  	1. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。
  	1. 将新元素添加到底层数组里面。

  > 最后将encoding属性升级，再增加length属性

#### 升级之后新元素的摆放位置

- 因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：

  		- 在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；
  	
  		- 在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。

### 升级的好处

- 提升灵活性

  因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以通过升级来适应新元素，非常灵活

- 节约内存

  如果有使用场景需要将int16_t、int32_t、int64_t同时保存到一个数组中，最直接想到的应该int64_t[]数组存储所有元素，但如果使用场景中int16_t元素很多，int16_t元素装进int64_t[]，会浪费很多内存空间。

  通过升级能在只有int16_t的时候只用int16_t[]，节省了内存

### 降级（不支持）

- 整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

![image-20211124005538110](https://tva1.sinaimg.cn/large/008i3skNly1gwpkm5kazkj30vg09mq49.jpg)

## 第7章　压缩列表（旧版本List的底层数据结构）

- 压缩列表（ziplist）是列表键和哈希键的底层实现之一。
  - 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
  - 另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

### 压缩列表的构成

- 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

![image-20211124010511321](/Users/zhenheng.lhl/Library/Application Support/typora-user-images/image-20211124010511321.png)

### 压缩列表节点的构成

- 每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成

#### previous_entry_length

- 节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。
- previous_entry_length属性的长度可以是1字节或者5字节：
  	- 如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。
  	- 如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。

- 可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。

>  压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。

#### encoding

- 节点的encoding属性记录了节点的content属性所保存数据的类型以及长度

#### content

- 节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。

### 连锁更新（这是性能问题！所以Redis新版本转而使用quicklist）

- 因为previous_entry_length有可能是1字节有可能是5字节，当插入一个大于254字节的新元素到压缩列表头前时，如果之前的头元素（现在为压缩列表插入后第二个元素）的previous_entry_length为1字节，这时无法满足，需要扩展到5字节，第二个元素的扩展很可能引起第三个元素的扩展，以此类推。
- Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）。删除节点也可能会引发连锁更新。

![image-20211124011745004](https://tva1.sinaimg.cn/large/008i3skNgy1gwpl94o37uj30vi0u0gox.jpg)

- 因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N 2）。

- 要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：
  - 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；
  - 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；

- 因为以上原因，ziplistPush等命令的平均复杂度仅为O（N），在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。

![image-20211124011836840](https://tva1.sinaimg.cn/large/008i3skNgy1gwpla0kpqfj30vg0k4acx.jpg)

## quicklist快表（新版本List的底层数据结构）

- 在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。
- 其实 quicklist 就是「双向链表 + 压缩列表」组合，因为⼀个 quicklist 就是⼀个链表，⽽链表中的每个元素⼜是⼀个压缩列表。
- 压缩列表的性能问题：元素增加or增大会引发连锁更新，造成性能下降
- quicklist的解决办法：
  - 通过控制每个链表节点中的压缩列表的⼤⼩或者元素个数，来规避连锁更新的问题。
  - 因为压缩列表元素越少或越⼩，连锁更新带来的影响就越⼩，从⽽提供了更好的访问性能。
  - 在向 quicklist 添加⼀个元素的时候，不会像普通的链表那样，直接新建⼀个链表节点。⽽是会检查插⼊位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构⾥的压缩列表，如果不能容纳，才会新建⼀个新的 quicklistNode 结构。

```c
typedef struct quicklist {
  //quicklist的链表头
  quicklistNode *head; //quicklist的链表头
  //quicklist的链表头
  quicklistNode *tail;
  //所有压缩列表中的总元素个数
  unsigned long count;
  //quicklistNodes的个数
  unsigned long len;
  ...
} quicklist;

typedef struct quicklistNode {
  //前⼀个quicklistNode
  struct quicklistNode *prev; //前⼀个quicklistNode
  //下⼀个quicklistNode
  struct quicklistNode *next; //后⼀个quicklistNode
  //quicklistNode指向的压缩列表
  unsigned char *zl;
  //压缩列表的的字节⼤⼩
  unsigned int sz;
  //压缩列表的元素个数
  unsigned int count : 16; //ziplist中的元素个数
  ....
} quicklistNode;
```



![image-20211209123342107](https://tva1.sinaimg.cn/large/008i3skNly1gx7h32j96xj317k0dy3zw.jpg)

## listpack（Redis5.0的新底层数据结构）

- quicklist不能根除连锁更新效应，所以Redis5.0新设计了listpack，它的⽬的是替代压缩列表，它最⼤特点是 listpack 中每个节点不再包含前⼀个节点的⻓度了，压缩列表每个节点正因为需要保存前⼀个节点的⻓度字段，就会有连锁更新的隐患。

  > Redis6.2中hash对象、set对象的底层数据结构仍然是listpack，但最新代码（还未发布）已经将所有用到压缩列表的地方替换成了listpack

- listpack 没有压缩列表中记录前⼀个节点⻓度的字段了，listpack 只记录当前节点的⻓度，当我们向 listpack 加⼊⼀个新元素的时候，不会影响其他节点的⻓度字段的变化，从⽽避免了压缩列表的连锁更新问题。

![image-20211209124601868](https://tva1.sinaimg.cn/large/008i3skNly1gx7hfw7tp4j314g0ccab5.jpg)

## 第8章　对象

- Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。

- 使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

- 除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

- Redis键空间中对象与底层数据结构的关系（from小林图解redis）

  ![image-20211209095826025](https://tva1.sinaimg.cn/large/008i3skNgy1gx7clis0urj313s0gqtb8.jpg)

### 对象的类型与编码

- 每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。

- 以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值"msg"的对象，而键值对的值则是一个包含了字符串值"hello world"的对象：

  ```shell
  
  redis> SET msg "hello world"
  OK
  ```

- Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：

  ------

  > ```c
  > typedef struct redisObject {
  >     // 类型
  >     unsigned type:4;
  >     // 编码
  >     unsigned encoding:4;
  >     // 指向底层实现数据结构的指针
  >     void *ptr;
  >     // ...
  > } robj;
  > ```

#### 类型

- 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种
- 当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型

```shell
# 键为字符串对象，值为字符串对象
redis> SET msg "hello world"
OK
redis> TYPE msg
string
# 键为字符串对象，值为列表对象
redis> RPUSH numbers 1 3 5
(integer) 6
redis> TYPE numbers
list
# 键为字符串对象，值为哈希对象
redis> HMSET profile name Tom age 25 career Programmer
OK
redis> TYPE profile
hash
# 键为字符串对象，值为集合对象
redis> SADD fruits apple banana cherry
(integer) 3
redis> TYPE fruits
set
# 键为字符串对象，值为有序集合对象
redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
redis> TYPE price
zset
```

#### 编码和底层实现

- 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。
- encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现

![image-20211127212734011](https://tva1.sinaimg.cn/large/008i3skNly1gwu18zods7j318m0jcdij.jpg)

- 每种类型的对象都至少使用了两种不同的编码，如

![image-20211127213412708](https://tva1.sinaimg.cn/large/008i3skNly1gwu19rl3u8j318m0qun27.jpg)

>  使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码

- 通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

> 举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：
>
> - 因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；
>
> - 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；

### 字符串对象

- 字符串对象的编码可以是int、raw或者embstr。

  - 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。

  - 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。ptr属性指向这个sdshdr

  - 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。

    > embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，如图8-3所示。
    >
    > ![image-20211127221219781](https://tva1.sinaimg.cn/large/008i3skNly1gwu2df46f3j314006g754.jpg)

#### 编码的转换

- int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。

#### 字符串命令的实现

- 因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的

![image-20211128150925335](https://tva1.sinaimg.cn/large/008i3skNly1gwuvrprg4qj312z0u0dl6.jpg)

![image-20211128150948904](https://tva1.sinaimg.cn/large/008i3skNly1gwuvs45lcpj318i0p0jvh.jpg)

### 列表对象（3.2版本后只能由quicklist实现！）

- 列表对象的编码可以是ziplist或者linkedlist。举个例子：

```shell

redis> RPUSH numbers 1 "three" 5
(integer) 3
```

![image-20211128234033526](https://tva1.sinaimg.cn/large/008i3skNgy1gwvajjmbljj310o0dg3ze.jpg)

![image-20211128234050687](https://tva1.sinaimg.cn/large/008i3skNgy1gwvaju3t5uj310i0e4404.jpg)

#### 编码转换

- 只有当满足下面两个条件，列表对象才能用ziplist编码，否则只能用linkedlist

  - 列表对象保存的所有字符串元素的长度都小于64字节；

  - 列表对象保存的元素数量小于512个；

#### 列表命令的实现

- 因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建

![image-20211128152131166](https://tva1.sinaimg.cn/large/008i3skNly1gwuw4aln9nj30u016etfb.jpg)

### 哈希对象

- 哈希对象的编码可以是ziplist或者hashtable。

- ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：
  - 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
  - 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

- 举例：

  ```shell
  (integer) 1
  redis> HSET profile age 25
  (integer) 1
  redis> HSET profile career "Programmer"
  (integer) 1
  
  ```

  ![image-20211128152410661](https://tva1.sinaimg.cn/large/008i3skNly1gwuw721c0zj319m0owacv.jpg)

- 另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
  - 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
  - 字典的每个值都是一个字符串对象，对象中保存了键值对的值。

​	![image-20211128152455297](https://tva1.sinaimg.cn/large/008i3skNly1gwuw7u0xw7j31120p8go4.jpg)

#### 编码转换

- 只有满足下面两个条件时，哈希对象才能使用ziplist编码，否则要用hashtable编码：

  	- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
  	
  	- 哈希对象保存的键值对数量小于512个；

#### 哈希命令的实现

- 因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的

![image-20211128153021624](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwdj0hxuj30x40u0wj7.jpg)

### 集合对象

- 集合对象的编码可以是intset或者hashtable。

- intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

  ```shell
  redis> SADD numbers 1 3 5
  (integer) 3
  
  ```

- 另一方面，hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

  ```shell
  redis> SAD Dfruits "apple" "banana" "cherry"
  (integer)3
  ```

  ![image-20211128153305172](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwgbvh8cj310y0tqn0s.jpg)

#### 编码的转换

- 只有当满足下面两个条件时，集合对象才使用intset编码，否则就要用hashtable编码：

  - 集合对象保存的所有元素都是整数值；

  - 集合对象保存的元素数量不超过512个。

#### 集合命令的实现

- 因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的

![image-20211128153424483](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwhpnd0zj318o07o0tt.jpg)

![image-20211128153433447](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwhuu7axj311k0u0wjt.jpg)

### 有序集合对象

- 有序集合的编码可以是ziplist或者skiplist。

- ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。

  - 压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

    ```shell
    redis> ZADD price 8.5 apple 5.0 banana 6.0 cherry
    (integer) 3
    ```

- skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

------

> ```c
> typedef struct zset {
>     zskiplist *zsl;
>     dict *dict;
> } zset;
> 
> ```

![image-20211128154004730](https://tva1.sinaimg.cn/large/008i3skNly1gwuwnlmdb6j318w08sdh7.jpg)

- zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。

- 除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。

- 值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以**同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值**，也不会因此而浪费额外的内存。

> 为什么有序集合需要同时使用跳跃表和字典来实现？
>
> 如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。
>
> 另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合

- 举个例子，如果前面price键创建的不是ziplist编码的有序集合对象，而是skiplist编码的有序集合对象，那么这个有序集合对象将会是图8-16所示的样子，而对象所使用的zset结构将会是图8-17所示的样子。

![image-20211128154421064](https://tva1.sinaimg.cn/large/008i3skNly1gwuws2fds7j30u016r42i.jpg)

> 为了展示方便，图8-17在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存。

#### 编码的转换

- 只有当下面两个条件都满足时，有序列表对象才能使用ziplist编码，否则要用skiplist编码：
  - 有序集合保存的元素数量小于128个；
  - 有序集合保存的所有元素成员的长度都小于64字节；

#### 有序集合命令的实现

- 因为有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的

![image-20211128154600999](https://tva1.sinaimg.cn/large/008i3skNgy1gwuwtsf04sj30u0109wjv.jpg)

### 类型检查与命令多态

- Redis中用于操作键的命令基本上可以分为两种类型。

- 其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。

  ```shell
  
  # 字符串键
  redis> SET msg "hello"
  OK
  # 列表键
  redis> RPUSH numbers 1 2 3
  (integer) 3
  # 集合键
  redis> SADD fruits apple banana cherry
  (integer) 3
  redis> DEL msg
  (integer) 1
  redis> DEL numbers
  (integer) 1
  redis> DEL fruits
  (integer) 1
  ```

  

- 而另一种命令只能对特定类型的键执行，比如说：

  - SET、GET、APPEND、STRLEN等命令只能对字符串键执行；

  - HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；

  - RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；

  - SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；

  - ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；

#### 类型检查的实现

- 类型检查是通过redisObject结构的type属性来实现的

> 举个例子，对于LLEN命令来说：
>
> - 在执行LLEN命令之前，服务器会先检查输入数据库键的值对象是否为列表类型，也即是，检查值对象redisObject结构type属性的值是否为REDIS_LIST，如果是的话，服务器就对键执行LLEN命令；
>
> - 否则的话，服务器就拒绝执行命令并向客户端返回一个类型错误；

#### 多态命令的实现

- Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。借用面向对象方面的术语来说，我们可以认为LLEN命令是多态（polymorphism）的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行。

- 如果我们对一个键执行LLEN命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令实现：

  - 如果列表对象的编码为ziplist，那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表的长度；

  - 如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度；

### 内存回收

- 因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

- 每个对象的引用计数信息由redisObject结构的refcount属性记录：

------

> ```c
> 
> typedef struct redisObject {
>     // ...
>     // 引用计数
>     int refcount;
>     // ...
> } robj;
> ```

------

- 对象的引用计数信息会随着对象的使用状态而不断变化：
  - 在创建一个新对象时，引用计数的值会被初始化为1；
  - 当对象被一个新程序使用时，它的引用计数值会被增一；
  - 当对象不再被一个程序使用时，它的引用计数值会被减一；
  - 当对象的引用计数值变为0时，对象所占用的内存会被释放。

![image-20211128230849093](https://tva1.sinaimg.cn/large/008i3skNgy1gwv9mjn3bgj318e0aign3.jpg)

> 使用OBJECT REFCOUNT命令查看键A的值对象的引用计数

### 对象共享

- 除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用

- 在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

  1）将数据库键的值指针指向一个现有的值对象；

  2）将被共享的值对象的引用计数增一。

- 尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享

  > 当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：
  > - 如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）；
  > - 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；
  > - 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N 2）。

### 对象的空转时长

- redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间

  > OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的（这个命令在访问键的值对象时，不会修改值对象的lru属性）

## 第9章　数据库

### 服务器中的数据库

- Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库，在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：

------

> ```c
> struct redisServer {
>     // ...
>     // 一个数组，保存着服务器中的所有数据库
>     redisDb *db;
>     // ...
>   	// 服务器的数据库数量
>     int dbnum;
>   	// ...
>   	// 数据库键空间，保存着数据库中的所有键值对
>     dict *dict;
>      // 过期字典，保存着键的过期时间
>     dict *expires;
> };
> 
> ```

------

- dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16

### 切换数据库

- 每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。

- 默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。

- 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针，指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库：

------

> ```c
> typedef struct redisClient {
> // ...
> // 记录客户端当前正在使用的数据库
> redisDb *db;
> // ...
> } redisClient;
> 
> ```

------

> 有些客户端不会显示目标数据库的号码，那可能会在多次切换后忘记自己，所以最好在执行危险命令前（如FLUSHDB清空整个数据库）执行一个SELECT命令

### 数据库键空间

- Redis是一个键值对（key-value pair）数据库服务器，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：

  ```c
  typedef struct redisDb {
      // ...
      // 数据库键空间，保存着数据库中的所有键值对
      dict *dict;
      // ...
  } redisDb;
  
  ```

  

- 键空间和用户所见的数据库是直接对应的：

  - 键空间的键也就是数据库的键，每个键都是一个字符串对象。
  - 键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。

- 举例：

  ```shell
  redis> SET message "hello world"
  OK
  redis> RPUSH alphabet "a" "b" "c"
  (integer)3
  redis> HSET book name "Redis in Action"
  (integer) 1
  redis> HSET book author "Josiah L. Carlson"
  (integer) 1
  redis> HSET book publisher "Manning"
  (integer) 1
  
  ```

![image-20211128234302333](https://tva1.sinaimg.cn/large/008i3skNly1gwvam44oxaj315v0u0dj1.jpg)

#### 增删改查

- 添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。

- 删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。
- 对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。

- 对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象

```shell

redis> SET date "2013.12.1"
OK
redis> DEL book
(integer) 1
redis> SET message "blah blah" # 键message的值对象将从之前包含"hello world"字符串更新为包含"blah blah"字符串
OK
redis> HSET book page 320
(integer) 1
redis> GET message
"hello world"
redis> LRANGE alphabet 0 -1
1)"a"
2)"b"
3)"c"

```

#### 其他键空间操作

- 比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。

- 另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。

#### 读写键空间时的维护操作

- 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数

  >  这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。

- 在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间

  >  使用OBJECT idletime命令可以查看键key的闲置时间。

- 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作

- 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过

- 服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作

- 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知

### 设置键的生存时间或过期时间

- 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：

  ```shell
  redis> SET key value
  OK
  redis> EXPIRE key 5
  (integer) 1
  redis> GET key  // 5
  秒之内
  "value"
  redis> GET key  // 5
  秒之后
  (nil)
  ```

  > SETEX命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令（只能用于字符串键）

- 与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键：

  ```shell
  redis> SET key value
  OK
  redis> EXPIREAT key 1377257300
  (integer) 1
  redis> TIME
  1)"1377257296"
  2)"296543"
  redis> GET key    // 1377257300
  之前
  "value"
  redis> TIME
  1)"1377257303"
  2)"230656"
  redis> GET key    // 1377257300
  之后
  (nil)
  ```

  

> TTL命令（秒）和PTTL命令（毫秒）接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间

#### 设置过期时间

- Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：

  ```shell
  ·EXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl秒。
  
  ·PEXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl毫秒。
  
  ·EXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
  
  ·PEXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。
  ```

- 实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：

#### 保存过期时间

- redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：
  - 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。
  - 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

#### 移除过期时间

- PERSIST命令可以移除一个键的过期时间：在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联

### 过期键删除策略

- 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。

- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。

- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

#### 定时删除

- 对内存最友好：可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存
- 对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间
- 除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件
- 因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。

#### 惰性删除

- 对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。
- 缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。

- redis非常依赖于内存，大量过期键没有被访问也就无法删除（除非用户手动FLUSHDB），甚至可以看成内存泄露。对于有些数据如日志，访问量大大减少，而造成redis服务器内存紧张

#### 定期删除

- 定期删除策略是前两种策略的一种整合和折中：
  - 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
  - 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。
-  难点是确定删除操作执行的时长和频率：
  - 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。
  - 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。

### Redis的过期键删除策略

- Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。

#### 惰性删除策略的实现

- 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查

- expireIfNeeded函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键。
- 因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况

#### 定期删除策略的实现

- 过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。工作过程如下：
  - 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
  - 全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。
  - 随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。

- 伪代码：

```python
# 默认每次检查的数据库数量
DEFAULT_DB_NUMBERS = 16
# 默认每个数据库检查的键数量
DEFAULT_KEY_NUMBERS = 20
# 全局变量，记录检查进度
current_db = 0
def activeExpireCycle():
    # 初始化要检查的数据库数量
    # 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 
要小
    # 那么以服务器的数据库数量为准
    if server.dbnum < DEFAULT_DB_NUMBERS:
        db_numbers = server.dbnum
    else:
        db_numbers = DEFAULT_DB_NUMBERS
    # 遍历各个数据库
    for i in range(db_numbers):
        # 如果current_db的值等于服务器的数据库数量
        # 这表示检查程序已经遍历了服务器的所有数据库一次
        # 将current_db重置为0，开始新的一轮遍历
        if current_db == server.dbnum:
            current_db = 0
        # 获取当前要处理的数据库
        redisDb = server.db[current_db]
        # 将数据库索引增1，指向下一个要处理的数据库
        current_db += 1
        # 检查数据库键
        for j in range(DEFAULT_KEY_NUMBERS):
            # 如果数据库中没有一个键带有过期时间，那么跳过这个数据库
            if redisDb.expires.size() == 0: break
            # 随机获取一个带有过期时间的键
            key_with_ttl = redisDb.expires.get_random_key()
            # 检查键是否过期，如果过期就删除它
            if is_expired(key_with_ttl):
                delete_key(key_with_ttl)
            # 已达到时间上限，停止处理
            if reach_time_limit(): return
```

### AOF、RDB和复制功能对过期键的处理

> Redis 持久化之RDB和AOF：https://www.cnblogs.com/itdragon/p/7906481.html

#### 生成RDB文件

- 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

#### 载入RDB文件

- 在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
  - 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
  - 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

#### AOF文件写入（AppendOnly File）

- 当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

- 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

#### AOF重写

- 和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。
- 因此，数据库中包含过期键不会对AOF重写造成影响。

#### 复制

- 当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：
  - 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。	
  - 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。
  - 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。

- 通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。

  > 如果从服务器接收到过期键的get请求，仍然返回键的值，就好像这个键没过期一样。
  >
  > 只有当主服务器删除这个过期键，并且向从服务器发送了DEL命令，从服务器才会把过期键删除
  >
  > 从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性

#### 数据库通知

- 数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。

- 关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification）

  ```shell
  
  # 获取0号数据库中针对message键执行的所有命令
  127.0.0.1:6379> SUBSCRIBE _ _keyspace@0_ _:message
  Reading messages... (press Ctrl-C to quit)
  1) "subscribe"  // 订阅信息
  2) "__keyspace@0__:message"     
  3) (integer) 1  
  1) "message"    //执行SET命令
  2) "_ _keyspace@0_ _:message"   
  3) "set"        
  1) "message"    //执行EXPIRE命令
  2) "_ _keyspace@0_ _:message"   
  3) "expire"     
  1) "message"    //执行DEL命令
  2) "_ _keyspace@0_ _:message"   
  3) "del"     
  ```

- 键事件通知（key-event notification）的通知,关注的是“某个命令被什么键执行了”

  ```shell
  # 获取0号数据库中所有执行DEL命令的键
  127.0.0.1:6379> SUBSCRIBE _ _keyevent@0_ _:del
  Reading messages... (press Ctrl-C to quit)
  1) "subscribe"  // 订阅信息
  2) "_ _keyevent@0_ _:del"
  3) (integer) 1
  1) "message"    //键key执行了DEL命令
  2) "_ _keyevent@0_ _:del"
  3) "key"
  1) "message"    //键number执行了DEL命令
  2) "_ _keyevent@0_ _:del"
  3) "number"
  1) "message"    //键message执行了DEL命令
  2) "_ _keyevent@0_ _:del"
  3) "message"
  ```


## 第10章 RDB持久化

- 因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。
- 为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。

- RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态

### RDB文件的创建与载入

- 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。

- SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
- BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求

- RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。

#### BGSAVE命令执行时的服务器状态

- 在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。

- 其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。

- 最后，出于性能考虑，BGREWRITEAOF和BGSAVE两个命令不能同时执行（后来的命令延迟到前者执行完毕后再执行）

#### RDB文件载入时的服务器状态

- 服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止

### 自动间隔性保存

- 因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。

- 保存条件由saveparams数组维护：

  ```c
  struct redisServer {
      // ...
      // 记录了保存条件的数组
      struct saveparam *saveparams;
      // ...
  };
  struct saveparam {
      // 秒数
      time_t seconds;
      // 修改数
      int changes;
  };
  
  
  ```

  ```shell
  save 900 1 # 服务器在900秒之内，对数据库进行了至少1次修改。对应saveparam结构体
  save 300 10
  save 60 10000
  ```

  

#### dirty&lastsave

- dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。
- lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

```c
struct redisServer {
    // ...
    // 修改计数器
    long long dirty;
    // 上一次执行保存的时间
    time_t lastsave;
    // ...
};
```

#### 检查保存条件是否满足

- Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

- 遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令

### RDB文件结构

![image-20211130011112017](https://tva1.sinaimg.cn/large/008i3skNgy1gwwis7bpo2j310s04u0t7.jpg)

### 分析RDB文件

- 人工分析RDB文件：od命令可以用给定的格式转存（dump）并打印输入文件。比如说，给定-c参数可以以ASCII编码的方式打印输入文件，给定-x参数可以以十六进制的方式打印输入文件
- Redis-check-dump之类的工具，网上有很多

> 《Redis RDB文件格式》：https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format

## 第11章　AOF持久化

- 与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的

  ![image-20211202174454889](https://tva1.sinaimg.cn/large/008i3skNgy1gwzmqr716bj30x0098t9i.jpg)

  ```shell
  redis> SET msg "hello"
  OK
  redis> SADD fruits "apple" "banana" "cherry"
  (integer) 3
  redis> RPUSH numbers 128 256 512
  (integer) 3
  ```

- 被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容

  ```shell
  
  *2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
  *3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
  *5\r\n$4\r\nSADD\r\n$6\r\nfruits\r\n$5\r\napple\r\n$6\r\nbanana\r\n$6\r\ncherry\r\n
  *5\r\n$5\r\nRPUSH\r\n$7\r\nnumbers\r\n$3\r\n128\r\n$3\r\n256\r\n$3\r\n512\r\n
  ```

### AOF持久化的实现

AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

#### 命令追加

- 当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾

#### AOF文件的写入与同步

- Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数

> 为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。
>
> 这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。
>
> 为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。

- 服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。

  - 当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。

  - 当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。

  - 当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。

### AOF文件的载入与数据还原

- 因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。

- Redis读取AOF文件并还原数据库状态的详细步骤如下：

  1）创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。

  2）从AOF文件中分析并读取出一条写命令。

  3）使用伪客户端执行被读出的写命令。

  4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。

### AOF重写

- 随着服务器运行时间的流逝，AOF文件中的内容会越来越多

- 为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。
- 虽然Redis这个功能名为『重写』，但是并不会对原AOF文件进行任何读取、分析或者写入操作，只需要对数据库状态进行分析再计算出最简短的AOF写命令再替换原AOF文件即可

> 为了避免客户端输入缓冲区溢出，在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果超过阈值（64），则会用多条写命令

#### AOF后台重写

- 作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行

- 不过，使用子进程需要解决状态不一致的问题，Redis是通过AOF重写缓冲区解决的

  ![image-20211206000045558](https://tva1.sinaimg.cn/large/008i3skNly1gx3egr8naej311y0g0wg9.jpg)

- 追加命令不仅到AOF缓冲区，还到AOF重写缓冲区

- 当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：

  1）将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。

  2）对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。

## 第12章　事件

- Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
  - 文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
  - 时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。

### 文件事件

- 虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。

#### 文件事件处理器的构成

四个构成

![image-20211206000754163](https://tva1.sinaimg.cn/large/008i3skNly1gx3eo5f245j30xe0qsq61.jpg)

- 文件事件是对套接字操作的抽象，I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。
- 尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。

#### I/O多路复用程序的实现

- Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c，这些底层实现可以互换

- Redis在I/O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现：

  ```c
  /* Include the best multiplexing layer supported by this system.
    * The following should be ordered by performances, descending. */
  # ifdef HAVE_EVPORT
  # include "ae_evport.c"
  # else
      # ifdef HAVE_EPOLL
      # include "ae_epoll.c"
      # else
          # ifdef HAVE_KQUEUE
          # include "ae_kqueue.c"
          # else
          # include "ae_select.c"
          # endif
      # endif
  # endif
  ```

#### 事件的类型

- I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：
  - 当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。
  - 当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。

- 如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件；这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。

#### 文件事件的处理器

- Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：

  - ·为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。
    - networking.c/acceptTcpHandler函数
    - 具体实现为sys/socket.h/accept函数的包装
    - 与AE_READABLE事件关联，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件

  - ·为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。
    - networking.c/readQueryFromClient函数
    - 具体实现为unistd.h/read函数的包装
    - 与AE_READABLE事件关联，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件
    - 客户端连接服务器的整个过程，关联都存在

  - ·为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。
    - networking.c/sendReplyToClient函数
    - 具体实现为unistd.h/write函数的包装
    - 与AE_READABLE事件关联，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件
    - 当命令回复发送完毕之后，与AE_READABLE解除关联

  - ·当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。

### 时间事件

- Redis的时间事件分为以下两类：

  - ·定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。

  - ·周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。

- 一个时间事件主要由以下三个属性组成：
  - ·id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。
  - ·when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。
  - ·timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。

#### 实现

- 服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。

- 正常模式下的Redis服务器只使用serverCron一个时间事件，服务器几乎是将无序链表退化成一个指针来使用，所以无序链表并不影响时间事件处理器的性能

#### 时间事件应用实例：serverCron函数

- 持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：
  - ·更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。
  - ·清理数据库中的过期键值对。
  - ·关闭和清理连接失效的客户端。
  - ·尝试进行AOF或RDB持久化操作。
  - ·如果服务器是主服务器，那么对从服务器进行定期同步。
  - ·如果处于集群模式，对集群进行定期同步和连接测试。
- Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。
  - 在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。
  - 从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。

### 事件的调度与执行

- 事件的调度和执行由ae.c/aeProcessEvents函数负责

```python
def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0
    if remaind_ms < 0:
        remaind_ms = 0
    # 根据remaind_ms的值，创建timeval结构
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
    # 如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    processFileEvents() # 实际上不存在该函数，这里把逻辑聚合到一个不存在的函数中
    # 处理所有已到达的时间事件
    processTimeEvents()
```

![image-20211206003603045](https://tva1.sinaimg.cn/large/008i3skNly1gx3fhfsbifj30ve0p2gnw.jpg)

- 对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，时间/文件处理器都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性
- 因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些

## 第13章　客户端

- Redis服务器是典型的一对多服务器程序，使用单线程单进程的方式来处理命令请求
- 服务器为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：
  - ·客户端的套接字描述符。
  - ·客户端的名字。
  - ·客户端的标志值（flag）。
  - ·指向客户端正在使用的数据库的指针，以及该数据库的号码。
  - ·客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。
  - ·客户端的输入缓冲区和输出缓冲区。
  - ·客户端的复制状态信息，以及进行复制所需的数据结构。
  - ·客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。
  - ·客户端的事务状态，以及执行WATCH命令时用到的数据结构。
  - ·客户端执行发布与订阅功能时用到的数据结构。
  - ·客户端的身份验证标志。
  - ·客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。

### 客户端属性

#### 套接字描述符fd

- 客户端状态的fd属性记录了客户端正在使用的套接字描述符
  - ·伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接
  - ·普通客户端的fd属性的值为大于-1的整数
- 执行CLIENT list命令可以列出目前所有连接到服务器的普通客户端

```shell

redis> CLIENT list
addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0 ...
addr=127.0.0.1:53469 fd=7 name= age=4 idle=4 ...

```

#### 名字name

- 默认客户端是没名字的，但可以使用CLIENT setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰，name属性指向一个字符串对象

#### 标志flags

- 客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态
- 标志属性可以是单个标志，也可以多个标志的二进制或
- 每个标志使用一个常量表示，所有标志都定义在redis.h文件

#### 输入缓冲区querybuf

- 客户端状态的输入缓冲区用于保存客户端发送的命令请求
- 输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端。

#### 命令与命令参数argv,argc

- 在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性

#### 命令的实现函数cmd

- 当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。

#### 输出缓冲区buf，reply

- 执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：
  - ·固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。固定大小缓冲区由buf（字节数组）和bufpos（buf数组目前已使用的字节数）两个属性组成
  - ·可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。可变大小缓冲区由reply链表和一个或多个字符串对象组成

#### 身份验证

- 客户端状态的authenticated属性用于记录客户端是否通过了身份验证
- 为0则未通过，为1则已通过，为0时，除了AUTH命令，客户端发送的其他命令都会被服务器拒绝

#### 时间

- ctime属性记录了创建客户端的时间；CLIENT list命令的age域记录了这个秒数

- lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间，这里的互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复。CLIENT list命令的idle域记录了这个秒数
- obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间，

### 客户端的创建与关闭

#### 创建



#### 关闭

- 一个普通客户端可以因为多种原因而被关闭：
  - ·如果客户端进程退出或者被杀死
  - ·如果客户端向服务器发送了带有不符合协议格式的命令请求
  - ·如果客户端成为了CLIENT KILL命令的目标
  - ·如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。
  - 如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB）
  - ·如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。

- 为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。
  - 硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。
  - 软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间。
    - 如果输出缓冲区大小一直超出软性限制，并且持续时间超过设定时长，则服务器将关闭客户端；
    - 如果在指定时间内输出缓冲区大小不再大于软性限制，那么客户端也不被关闭，且obuf_soft_limit_reached_time也会被清零

#### Lua脚本的伪客户端

- 服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中
- lua_client伪客户端在服务器运行的整个生命期中会一直存在

#### AOF文件的伪客户端

- 服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。

## 第14章　服务器

### 命令请求的执行过程

#### 命令执行器（1）：查找命令实现

- 命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。
- 命令表是一个字典，字典的键是一个个命令名字，比如"set"、"get"、"del"等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息

![image-20211206010001704](https://tva1.sinaimg.cn/large/008i3skNly1gx3g6dvuvkj30u00wh77w.jpg)

- 命令名字的大小写不影响命令表的查找结果

#### 命令执行器（2）：执行预备操作

> ·检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。
>
> ·根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。
>
> ·检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。
>
> ·如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。
>
> ·如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。
>
> ·如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。
>
> ·如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。
>
> ·如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。
>
> ·如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。
>
> ·如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令

#### 命令执行器（3）：调用命令的实现函数

- 在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：client->cmd->proc(client);

- 被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。

#### 令执行器（4）：执行后续工作

- 在执行完实现函数之后，服务器还需要执行一些后续工作：

  - ·如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。

  - ·根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。

  - ·如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。

  - ·如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。

### serverCron函数

- Redis服务器中的serverCron函数默认每隔100毫秒执行一次

#### 更新服务器时间缓存（不准确

- 为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存

  > 只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上

- 对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间

#### 更新LRU时钟（不准确

- 服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种

- 每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间

- 当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间

#### 更新服务器每秒执行命令次数

- serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量

#### 更新服务器内存峰值记录

- 服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小

- 每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么程序就将当前使用的内存数量记录到stat_peak_memory属性里面。

#### 处理SIGTERM信号

- 在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识
- 每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器
- shutdown_asap为1关闭，为0无动作
- 服务器在关闭自身之前会进行RDB持久化操作，这也是服务器拦截SIGTERM信号的原因

#### 管理客户端资源

- serverCron函数每次执行都会调用clientsCron函数：
  - ·如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。
  - ·如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。

#### 管理数据库资源

- serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作，第9章经对这些操作进行了详细的说明。

#### 执行被延迟的BGREWRITEAOF

- 在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。

#### 检查持久化操作的运行状态

- 服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行

#### 将AOF缓冲区中的内容写入AOF文件

- 如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序

#### 关闭异步客户端

- 服务器会关闭那些输出缓冲区大小超出限制的客户端

#### 增加cronloops计数器的值

- 服务器状态的cronloops属性记录了serverCron函数执行的次数
- 唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能

### 初始化服务器

#### 初始化服务器状态结构

- 初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。

- 初始化server变量的工作由redis.c/initServerConfig函数完成，

  ```c
  void initServerConfig(void){
      // 设置服务器的运行id 
      getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);
      // 为运行id加上结尾字符
      server.runid[REDIS_RUN_ID_SIZE] = '\0';
      // 设置默认配置文件路径
      server.configfile = NULL;
      // 设置默认服务器频率
      server.hz = REDIS_DEFAULT_HZ;
      // 设置服务器的运行架构
      server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
      // 设置默认服务器端口号
      server.port = REDIS_SERVERPORT;
      // ...
  }
  ```

  

#### 载入配置选项

- 在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。

  ```shell
  $ redis-server --port 10086
  $ redis-server redis.conf
  
  ```

  

#### 初始化服务器数据结构

- 在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：
  - ·server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。
  - ·server.db数组，数组中包含了服务器的所有数据库。
  - ·用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。
  - ·用于执行Lua脚本的Lua环境server.lua。
  - ·用于保存慢查询日志的server.slowlog属性

- 除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：
  - ·为服务器设置进程信号处理器。
  - ·创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含"OK"回复的字符串对象，包含"ERR"回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。
  - ·打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。
  - ·为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。
  - ·如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。
  - ·初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备。

- 当initServer函数执行完毕之后，服务器将用ASCII字符在日志中打印出Redis的图标，以及Redis的版本号信息

#### 还原数据库状态

- 在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。

#### 执行事件循环

- 在初始化的最后一步，服务器将打印出以下日志：

```shell
[5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port 6379
```

​	并开始执行服务器的事件循环（loop）。

## 第15章　复制

- 在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）
- https://redis.io/topics/replication

### 旧版复制功能的实现

- Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作

#### 同步

- 当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，需要通过向主服务器发送SYNC命令来完成

- 以下是SYNC命令的执行步骤：

  - 1）从服务器向主服务器发送SYNC命令。
  - 2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
  - 3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。
  - 4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

  > SYNC命令是非常消耗资源的，主服务器需要执行BGSAVE好肥大量CPU、内存与磁盘I/O资源；而发送RDB文件又要耗费大量网络资源；而且从服务器在载入RDB时无法处理命令请求

#### 命令传播

- 在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种状态一致性可能会由于新的主服务器写命令而打破，这时就需要命令传播
- 主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行

### 旧版复制功能的缺陷

- 对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。
- 因为断线后重连需要重新发送SYNC命令给主服务器，SYNC命令非常消耗资源，假设从服务器仅断连了一小会，而主服务器键空间非常大，这时候SYNC就非常浪费资源

#### 新版复制功能的实现

- 为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。
- PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：
  - ·其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
  - ·而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，**主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器**，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

### 部分重同步的实现

- 在了解了PSYNC命令的由来，以及部分重同步的工作方式之后，是时候来介绍一下部分重同步的实现细节了。由以下三个部分构成：
  - ·主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。
  - ·主服务器的复制积压缓冲区（replication backlog）。
  - ·服务器的运行ID（run ID）。

#### 复制偏移量

- 执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：
  - ·主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。
  - ·从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。

- 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。否则就不相同

#### 复制积压缓冲区

- 复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。

- 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面
- 会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量

![image-20211207003030959](https://tva1.sinaimg.cn/large/008i3skNly1gx4ky0r8hhj318m0ew403.jpg)

- 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：
  - ·如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。
  - ·相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。

#### 服务器运行ID

- 除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）：
  - ·每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。
  - ·运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。
- 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。
- 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：
  - ·如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。
  - ·相反地，则不是之前那个主服务器，需要执行完整重同步，即发送SYNC命令。

### PSYNC命令的实现

- PSYNC命令的调用方法有两种：
  - ·如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）。
  - ·相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送`PSYNC <runid> <offset>`命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。
- 根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：
  - ·如果主服务器返回`+FULLRESYNC <runid> <offset>`回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。
  - ·如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。
  - ·如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。

### 复制的实现

- 从服务器发送SLAVEOF命令背后的细节流程

  - 步骤1：设置主服务器的地址和端口
  - 步骤2：建立套接字连接
  - 步骤3：发送PING命令（检查套接字读写是否正常、检查主服务器能否正常处理请求，若主服务器正常会回复"PONG"）
  - 步骤4：身份验证
  - 步骤5：发送端口信息（向主服务器发送从服务器的监听端口号）
  - 步骤6：同步（PYSNC命令）
    - 在执行同步操作之后，主服务器也会成为从服务器的客户端：
      - ·如果PSYNC命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。
      - ·如果PSYNC命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。

  - 步骤7：命令传播

### 心跳检测

- 在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令(其中replication_offset是从服务器当前的复制偏移量)：

  ```shell
  REPLCONF ACK <replication_offset>
  ```

- 发送REPLCONF ACK命令对于主从服务器有三个作用：

  - ·检测主从服务器的网络连接状态。

    > 通过向主服务器发送INFO replication命令，在列出的从服务器列表的lag一栏中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒
    >
    > 在一般情况下，lag的值应该在0秒或者1秒之间跳动，如果超过1秒的话，那么说明主从服务器之间的连接出现了故障。

  - ·辅助实现min-slaves选项。

    > Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。
    >
    > ```shell
    > 
    > min-slaves-to-write 3
    > min-slaves-max-lag 10
    > ```
    >
    > 那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值。

  - ·检测命令丢失。

    > 如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。

> REPLCONF ACK命令和复制积压缓冲区都是Redis 2.8版本新增的，以前的版本不会注意到命令在传播过程中的丢失，为了保证复制时的主从一致，请使用2.8或以上的Redis版本呢

## 第16章　Sentinel

- Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

![image-20211207105630994](https://tva1.sinaimg.cn/large/008i3skNly1gx531bzhy5j30xo0py40p.jpg)

![image-20211207105818703](https://tva1.sinaimg.cn/large/008i3skNly1gx5337iav0j30u01c3jvv.jpg)

### 启动并初始化Sentinel

- 启动一个Sentinel可以使用命令：

  ```shell
  $ redis-sentinel /path/to/your/sentinel.conf
  # or
  $ redis-server /path/to/your/sentinel.conf --sentinel
  ```

- 当一个Sentinel启动时，它需要执行以下步骤：
  - 1）初始化服务器。
  - 2）将普通Redis服务器使用的代码替换成Sentinel专用代码。
  - 3）初始化Sentinel状态。
  - 4）根据给定的配置文件，初始化Sentinel的监视主服务器列表。
  - 5）创建连向主服务器的网络连接。

#### 初始化服务器

- 首先，因为Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器，但是和普通的Redis服务器有所差别

  ![image-20211207114710569](https://tva1.sinaimg.cn/large/008i3skNgy1gx54i20zp7j30zz0u0n11.jpg)

#### 使用Sentinel专用代码

- 端口不同

  > 普通Redis使用6379，Sentinel使用26379

- 命令不同

  > Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令了。

#### 初始化Sentinel状态

```c
struct sentinelState {
    // 当前纪元，用于实现故障转移
    uint64_t current_epoch;
    // 保存了所有被这个sentinel监视的主服务器
    // 字典的键是主服务器的名字
    // 字典的值则是一个指向sentinelRedisInstance结构的指针
    dict *masters;
    // 是否进入了TILT模式？
    int tilt;
        // 目前正在执行的脚本的数量
    int running_scripts;
    // 进入TILT模式的时间
    mstime_t tilt_start_time;
    // 最后一次执行时间处理器的时间
    mstime_t previous_time;
    // 一个FIFO队列，包含了所有需要执行的用户脚本
    list *scripts_queue;
} sentinel;
```

#### 初始化Sentinel状态的masters属性

- Sentinel状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息，字典的键是被监视主服务器的名字，值是sentinel.c/sentinelRedisInstance结构（Redis服务器实例instance）

  ```c
  typedef struct sentinelRedisInstance {
      // 标识值，记录了实例的类型，以及该实例的当前状态
      int flags;
      // 实例的名字
      // 主服务器的名字由用户在配置文件中设置
      // 从服务器以及Sentinel的名字由Sentinel自动设置
      // 格式为ip:port，例如"127.0.0.1:26379"
      char *name;
      // 实例的运行ID
      char *runid;
      // 配置纪元，用于实现故障转移
      uint64_t config_epoch;
      // 实例的地址
      sentinelAddr *addr;
      // SENTINEL down-after-milliseconds选项设定的值
      // 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）
      mstime_t down_after_period;
      // SENTINEL monitor <master-name> <IP> <port> <quorum>选项中的quorum参数
      // 判断这个实例为客观下线（objectively down）所需的支持投票数量
      int quorum;
      // SENTINEL parallel-syncs <master-name> <number>选项的值
      // 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量
      int parallel_syncs;
      // SENTINEL failover-timeout <master-name> <ms>选项的值
      // 刷新故障迁移状态的最大时限
      mstime_t failover_timeout;
      // ...
  } sentinelRedisInstance;
  ```

#### 创建连向主服务器的网络连接

- 初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。

> Sentinel会创建两个连向主服务器的异步网络连接：
>
> - ·一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。
> - ·另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__:hello频道

### 获取主服务器信息

- Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的**主服务器**发送INFO命令

  >  通过INFO命令，主服务器属下的所有从服务器信息也可以被发现

### 获取从服务器信息

- 在创建命令连接之后，Sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送INFO命令

### 向主服务器和从服务器发送信息

- 在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器的的`__sentinel__:hello`频道发送信息

- 信息包括Sentinal本身的信息如IP、端口、运行id、epoch；还包括主/从服务器的名字、IP、端口、epoch

### 接收来自主服务器和从服务器的频道信息

- 对于每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的`__sentinel__:hello`频道发送信息，又通过订阅连接从服务器的`__sentinel__:hello`频道接收信息
- 对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。

> Sentinel在连接主服务器或者从服务器时，会同时创建命令连接和订阅连接，但是在连接其他Sentinel时，却只会创建命令连接，而不创建订阅连接。

### 检测主观下线状态

- 在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。

- 如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会在该实例的flags属性中打开SRI_S_DOWN标识，表示这个实例已经进入主观下线状态

- > down-after-milliseconds配置同样适用于该实例属下的所有从服务器

- 多个Sentinel设置的主观下线时长可能不同，因为down-after-milliseconds参数可能不同

### 检查客观下线状态

- 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）

- SENTINEL is-master-down-by-addr命令，这是向其他Sentinel的询问

```shell
SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <runid>
```

- SENTINEL is-master-down-by-addr命令，这是另一个Sentinel的回复，down_state为1则说明另一个sentinel也同意该主服务器下线

```shell

1) <down_state>
2) <leader_runid>
3) <leader_epoch>
```

- 当认为主服务器已经进入下线状态的Sentinel的数量，超过Sentinel配置中设置的quorum参数的值，那么该Sentinel就会认为主服务器已经进入客观下线状态

- 不同Sentinel判断客观下线的条件可能不同，因为quorum参数可能不同

### 选举领头Sentinel（Raft算法的实现）

- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。

- 具体规则：

  - 每个sentinel都有称为leader的资格，当sentinel发现有客观下线的主服务器后，就开始向其他sentinel拉票

  - 每个sentinel都只能投一票，在这次epoch（纪元）中不能更改

  - epoch（纪元）就是一次选举的过程，本质是个计数器，选举成功后所有sentinel的epoch都会自增

  - 当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel向自己投一票

  - sentinel投票的原则是：先到先得，命令先到的sentinel可以获得自己的投票

  - leader选举原则：超过半数，如果在10个sentinel组成的系统，只要某个sentinel获得了超过6张（包括自己的）选票，他就成为leader

- 因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel
- 如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止

> Sentinel系统选举领头Sentinel的方法是对Raft算法的领头选举方法的实现，关于这一方法的详细信息可以观看Raft算法的作者录制的“Raft教程”视频：http://v.youku.com/v_show/id_XNjQxOTk5MTk2.html，或者Raft算法的论文。

### 故障转移

- leader sentinel执行故障转移，步骤如下 

  - 1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器发送SLAVEOF no one命令，让其转换为主服务器。

    - 首先筛选出在线的、最近通信过INFO命令的、没有过早与主服务器断连的从服务器

    - 然后按照优先级最高、复制偏移量最大、运行id最小这三个顺序层层挑选

      > 在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了

  - 2）让已下线主服务器属下的所有从服务器改为复制新的主服务器

    - 向从服务器发送SLAVEOF命令，让从服务器去复制新的主服务器

  - 3）将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。

    - 当旧主服务器重新上线时，sentinel就会向它发送SLAVEOF命令，让其成为新主服务器的从服务器

- 当主服务器已下线，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。

## 第17章　集群

- Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。

### 节点

- 一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，即每个节点都是一个只包含单节点的集群
- 向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中

```shell
CLUSTER MEET <ip> <port>
```

- 启动节点

  - 一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式

  - 节点会继续使用单机模式中的服务器组件，如文件事件处理器、键空间、RDB/AOF持久化，复制，执行serverCron函数（其中会调用集群模式特有的clusterCron函数）

    > redisClient结构和clusterLink结构都有自己的套接字描述符和输入、输出缓冲区，这两个结构的区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的。

- CLUSTER MEET命令的实现，节点A所在集群添加节点B：

  - 1）节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。

  - 2）之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）。

  - 3）如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。

  - 4）之后，节点B将向节点A返回一条PONG消息。

  - 5）如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。

  - 6）之后，节点A将向节点B返回一条PING消息。

  - 7）如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。

  - 之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中的所有节点认识。

### 槽指派

- Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。
- 当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。

- 每个节点会负责一部分槽，并且会将这个信息告知其他节点；还有slots数组记录所有槽的指派信息

### 在集群中执行命令

- 当客户端向节点发送与数据库键有关的命令时，接收命令的节点计算出数据库键属于哪个槽，如果是自己的就自己处理了，如果不是自己的就向客户端返回MOVED错误，引导客户端转向（redirect）到相应的节点

  > 集群模式的redis-cli客户端在接收到MOVED错误时，并不会打印出MOVED错误，而是根据MOVED错误自动进行节点转向，并打印出转向信息，所以我们是看不见节点返回的MOVED错误的

- 计算逻辑：`slot_num = CRC16(key) & 16383`，CRC-16校验和

  > LUSTER KEYSLOT<key>命令可以查看一个给定键属于哪个槽

- 节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。

### 重新分片

- Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。
- 重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。

- Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。

### ASK错误

- 在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。
- 当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：
  - ·源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令。
  - ·相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。

> 集群模式的redis-cli在接到ASK错误时也不会打印错误，而是自动根据错误提供的IP地址和端口进行转向动作。如果想看到节点发送的ASK错误的话，可以使用单机模式的redis-cli客户端

### 复制与故障转移

- Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。
- 疑似下线：集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线（probable fail，PFAIL）。

- 超过半数原则：如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。

- 故障转移：当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：

  - 1）复制下线主节点的所有从节点里面，会有一个从节点被选中。

  - 2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。

  - 3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。

  - 4）新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。

  - 5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。

- 选举新的主节点：与sentinel选举leader的方式十分相似，都是基于Raft算法的leader election

### 消息

- 集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）

- 节点发送的消息主要有以下五种：

  - ·MEET消息：当发送者接到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。

  - ·PING消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。除此之外，如果节点A最后一次收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的cluster-node-timeout选项设置时长的一半，那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致对节点B的信息更新滞后。

  - ·PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。另外，一个节点也可以通过向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识，例如当一次故障转移操作成功执行之后，新的主节点会向集群广播一条PONG消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。

  - ·FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。

  - ·PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。

- 一条消息由消息头（header）和消息正文（data）组成
  - 因为MEET、PING、PONG三种消息都使用相同的消息正文，所以节点通过消息头的type属性来判断一条消息是MEET消息、PING消息还是PONG消息。
  - 在集群的节点数量比较大的情况下，单纯使用Gossip协议来传播节点的已下线信息会给节点的信息更新带来一定延迟，因为Gossip协议消息通常需要一段时间才能传播至整个集群，而发送FAIL消息可以让集群里的所有节点立即知道某个主节点已下线，从而尽快判断是否需要将集群标记为下线，又或者对下线主节点进行故障转移。

## 第18章　发布与订阅

- Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。

  - 通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。

  - 通过执行PSUBSCRIBE命令，客户端可以订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。

    > 模式的退订命令PUNSUBSCRIBE是PSUBSCRIBE命令的反操作

  - 通过PUBLISH命令，客户端可以向频道发布消息

> ```shell
> SUBSCRIBE "news.it" # 订阅news.it频道
> PUBLISH "news.it" "hello" # 向new.it频道发布hello消息
> ```

## 第19章　事务

- Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

  > ```shell
  > redis> MULTI
  > OK
  > redis> SET "name" "Practical Common Lisp"
  > QUEUED
  > redis> GET "name"
  > QUEUED
  > redis> SET "author" "Peter Seibel"
  > QUEUED
  > redis> GET "author"
  > QUEUED
  > redis> EXEC
  > 1) OK
  > 2) "Practical Common Lisp"
  > 3) OK
  > 4) "Peter Seibel"
  > ```

### 事务的实现

- 事务开始：MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的

- 命令入队（FIFO）：如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。

- 执行事务：当一个处于事务状态的客户端向服务器发送EXEC命令时，服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

### WATCH命令的实现

- WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。
- 使用WATCH命令监视数据库键：每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端

- 监视机制的触发：所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。

- 判断事务是否安全：当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务

### 事务的ACID性质

- 在传统的关系式数据库中，常常用ACID性质来检验事务功能的可靠性和安全性。
- 在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。

#### 原子性

- Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。
- Redis作者认为事务回滚的复杂与Redis追求简单高效的设计主旨不相符，所以就不支持了

#### 一致性

- 事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

- Redis通过谨慎的错误检测和简单的设计来保证事务的一致性：

  - 命令入队错误：出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。
  - 命令执行错误：服务器不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。

  - 服务器停机：当Redis运行无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的；如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态

#### 隔离性

- 事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。
- 因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断

#### 耐久性

- 事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。
  - 当服务器在无持久化的内存模式下运作时，事务不具有耐久性
  - 当服务器在RDB持久化模式下运作时，服务器只会在特定时机执行BGSAVE命令对数据库进行保存操作；并且BGSAVE是异步的，不能保证事务第一时间持久化
  - 当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，**具备耐久性**
  - 当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec/no时，不具备耐久性

- 不论Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事务的耐久性，不过因为这种做法的效率太低，所以并不具有实用性。

> ·Redis官方网站上的《事务》文档记录了Redis处理事务错误的方式，以及Redis不支持事务回滚的原因：http://redis.io/topics/transactions。

## Lua脚本

- 通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。

- 其中，使用EVAL命令可以直接对输入的脚本进行求值：

  ```shell
  redis> EVAL "return 'hello world'" 0"hello world"
  ```

### 创建并修改Lua环境

- Redis在服务器内嵌了一个Lua环境（environ-ment），并对这个Lua环境进行了一系列修改

- 创建Lua环境：服务器首先调用Lua的C API函数lua_open

- 载入函数库：

  - 基础库（base library）：这个库包含Lua的核心（core）函数，比如assert、error、pairs、tostring、pcall等
  - 表格库（table library）：这个库包含用于处理表格的通用函数，比如table.concat、table.insert、table.remove、table.sort等
  - ·字符串库（string library）：这个库包含用于处理字符串的通用函数，比如用于对字符串进行查找的string.find函数，对字符串进行格式化的string.format函数，查看字符串长度的string.len函数，对字符串进行翻转的string.reverse函数等。

  - ·数学库（math library）：这个库是标准C语言数学库的接口，它包括计算绝对值的math.abs函数，返回多个数中的最大值和最小值的math.max函数和math.min函数，计算二次方根的math.sqrt函数，计算对数的math.log函数等。

  - ·调试库（debug library）：这个库提供了对程序进行调试所需的函数，比如对程序设置钩子和取得钩子的debug.sethook函数和debug.gethook函数，返回给定函数相关信息的debug.getinfo函数，为对象设置元数据的debug.setmetatable函数，获取对象元数据的debug.getmetatable函数等。

  - ·Lua CJSON库（http://www.kyne.com.au/~mark/software/lua-cjson.php）：这个库用于处理UTF-8编码的JSON格式，其中cjson.decode函数将一个JSON格式的字符串转换为一个Lua值，而cjson.encode函数将一个Lua值序列化为JSON格式的字符串。

  - ·Struct库（http://www.inf.puc-rio.br/~roberto/struct/）：这个库用于在Lua值和C结构（struct）之间进行转换，函数struct.pack将多个Lua值打包成一个类结构（struct-like）字符串，而函数struct.unpack则从一个类结构字符串中解包出多个Lua值。

  - ·Lua cmsgpack库（https://github.com/antirez/lua-cmsgpack）：这个库用于处理MessagePack格式的数据，其中cmsgpack.pack函数将Lua值转换为MessagePack数据，而cmsgpack.unpack函数则将MessagePack数据转换为Lua值。

- 创建redis全局表格：在Lua环境中创建一个redis表格（table），最主要包含以下函数：用于执行Redis命令的redis.call和redis.pcall函数。通过这两个函数，用户可以直接在Lua脚本中执行Redis命令

  ```shell
  redis> EVAL "return redis.call('PING')" 0
  PONG
  ```

- 使用Redis自制的随机函数来替换Lua原有的随机函数

  - 为了保证相同的脚本可以在不同的机器上产生相同的结果，Redis要求所有传入服务器的Lua脚本，以及Lua环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure function）。

  - Redis使用自制的函数替换了带副作用的Lua函数，比如math.random、math.randomseed

- 创建排序辅助函数：
  - 对于Lua脚本来说，另一个可能产生不一致数据的地方是那些带有不确定性质的命令。比如对于一个集合键来说，因为集合元素的排列是无序的，所以即使两个集合的元素完全相同，它们的输出结果也可能并不相同
  - 为了消除这些命令带来的不确定性，服务器会为Lua环境创建一个排序辅助函数`__redis__compare_helper`，当Lua脚本执行完一个带有不确定性的命令之后，程序会使用`__redis__compare_helper`作为对比函数，自动调用table.sort函数对命令的返回值做一次排序，以此来保证相同的数据集总是产生相同的输出。

- 创建redis.pcall函数的错误报告辅助函数

- 保护Lua的全局环境

- 将Lua环境保存到服务器状态的lua属性里面

  > 因为Redis使用串行化的方式来执行Redis命令，所以在任何特定时间里，最多都只会有一个脚本能够被放进Lua环境里面运行，因此，整个Redis服务器只需要创建一个Lua环境即可。

### Lua环境协作组件

- 除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典。
- 伪客户端：因为执行Redis命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。
- lua_scripts字典：这个字典的键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本

### EVAL命令的实现

- 1）根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。
  - 使用函数来保存客户端传入的脚本有以下好处：
    - ·执行脚本的步骤非常简单，只要调用与脚本相对应的函数即可
    - ·通过函数的局部性来让Lua环境保持清洁，减少了垃圾回收的工作量，并且避免了使用全局变量
    - ·如果某个脚本所对应的函数在Lua环境中被定义过至少一次，那么只要记得这个脚本的SHA1校验和，就可以直接调用函数，这就是EVALSHA命令的实现原理
- 2）将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。
- 3）执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。
  - 准备和执行脚本的过程：
    - 将EVAL命令中传入的键名（key name）参数和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入到Lua环境里面。
    - 为Lua环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过SCRIPT KILL命令停止脚本，或者通过SHUTDOWN命令直接关闭服务器。
    - 执行脚本函数。
    - 移除之前装载的超时钩子。
    - 将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端。
    - 对Lua环境执行垃圾回收操作。

### EVALSHA命令的实现

- 每个被EVAL命令成功执行过的Lua脚本，在Lua环境里面都有一个与这个脚本相对应的Lua函数，函数的名字由f_前缀加上40个字符长的SHA1校验和组成
- 只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的

### 脚本管理命令的实现

- 除了EVAL命令和EVALSHA命令之外，Redis中与Lua脚本有关的命令还有四个，它们分别是SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令、以及SCRIPT KILL命令。

- SCRIPT FLUSH：用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境
- SCRIPT EXISTS：根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。
- SCRIPT LOAD：所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面
- SCRIPT KILL：如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子（hook）。

### 脚本复制

- 与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令、EVALSHA命令、SCRIPT FLUSH命令，以及SCRIPT LOAD命令。

- 复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令，与复制普通命令完全一样：命令传播（propagate）给所有从服务器
- EVALSHA命令比较复杂，因为主服务器与从服务器载入Lua脚本的情况可能有所不同，相同的EVALSHA命令在从服务器执行时却可能会出现脚本未找到（not found）错误
  - 主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器，键是一个个Lua脚本的SHA1校验和，而字典的值则全部都是NULL
  - 通过使用EVALSHA命令指定的SHA1校验和，以及lua_scripts字典保存的Lua脚本，服务器总可以将一个EVALSHA命令

> 《Lua 5.1 Reference Manual》对Lua语言的语法和标准库进行了很好的介绍：http://www.lua.org/manual/5.1/manual.html

## 第21章　排序

- Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。

- SORT命令的排序操作由快速排序算法实现

  ```shell
  redis> RPUSH numbers 5 3 1 4 2
  (integer) 5
  # 
  按插入顺序排列的列表元素
  redis> LRANGE numbers 0 -1
  1) "5"
  2) "3"
  3) "1"
  4) "4"
  5) "2"
  # 
  按值从小到大有序排列的列表元素
  redis> SORT numbers
  1) "1"
  2) "2"
  3) "3"
  4) "4"
  5) "5"
  ```

### `SORT<key>`命令的实现

- 1）**创建一个和numbers列表长度相同的数组**
- 2）遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系
- 3）遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面
- 4）根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排列
- 5）遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端

### ALPHA选项的实现

- 通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：

  ```shell
  redis> SADD fruits apple banana cherry
  (integer) 3
  # 元素在集合中是乱序存放的
  redis> SMEMBERS fruits
  1) "apple"
  2) "cherry"
  3) "banana"
  # 对fruits键进行字符串排序
  redis> SORT fruits ALPHA
  1) "apple"
  2) "banana"
  3) "cherry"
  ```

  

### ASC选项和DESC选项的实现

- 在默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列
- 在执行SORT命令时使用DESC选项，可以让命令执行降序排序，让排序后的结果按值的大小从大到小排列

### BY选项的实现

- 在默认情况下，SORT命令使用被排序键包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置。
- 另一方面，通过使用BY选项，SORT命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序。

### LIMIT选项的实现

- 在默认情况下，SORT命令总会将排序后的所有元素都返回给客户端
- 但是，通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素。

- `LIMIT<offset><count>`：

  - ·offset参数表示要跳过的已排序元素数量。

  - ·count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量。

### GET选项的实现

- 在默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素。
- 但是，通过使用GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。

### STORE选项的实现

- 在默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果
- 但是，通过使用STORE选项，我们可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果

### 多个选项的执行顺序

- 如果按照选项来划分的话，一个SORT命令的执行过程可以分为以下四步：

  - 1）排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集。

  - 2）限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。

  - 3）获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。

  - 4）保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。

  - 5）向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。

- 调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序

- 不过，如果命令包含了多个GET选项，那么在调整选项的位置时，我们必须保证多个GET选项的摆放顺序不变，这才可以让排序结果集保持不变。

  ```shell
  # 排序结果集相同
  SORT <key> GET <pattern-a> GET <pattern-b> STORE <store_key>
  SORT <key> STORE <store_key> GET <pattern-a> GET <pattern-b>
  
  # 排序结果集不同
  SORT <key> STORE <store_key> GET <pattern-a> GET <pattern-b>
  SORT <key> STORE <store_key> GET <pattern-b> GET <pattern-a>
  
  ```

## 第22章　二进制位数组

- Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组（bit array，又称“位数组”）。

- 其中，SETBIT命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值则可以是0或者1：

  ```shell
  redis> SETBIT bit 0 1  # 0000 0001 
  (integer) 0     
  redis> SETBIT bit 3 1        # 0000 1001 
  (integer) 0     
  redis> SETBIT bit 0 0        # 0000 1000 
  (integer) 1 
  ```

- 而GETBIT命令则用于获取位数组指定偏移量上的二进制位的值：

  ```shell
  redis> GETBIT bit 0 # 0000 1000
  (integer) 0
  redis> GETBIT bit 3 # 0000 1000
  (integer) 1
  ```

- BITCOUNT命令用于统计位数组里面，值为1的二进制位的数量：

  ```shell
  redis> BITCOUNT bit  # 0000 1000
  (integer) 1
  redis> SETBIT bit 0 1        # 0000 1001
  (integer) 0
  redis> BITCOUNT bit
  (integer) 2
  redis> SETBIT bit 1 1        # 0000 1011
  (integer) 0
  redis> BITCOUNT bit
  (integer) 3
  ```

- 最后，BITOP命令既可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）运算：

  ```shell
  redis> SETBIT x 3 1        # x = 0000 1011
  (integer) 0
  redis> SETBIT x 1 1
  (integer) 0
  redis> SETBIT x 0 1
  (integer) 0
  redis> SETBIT y 2 1  # y = 0000 0110
  (integer) 0
  redis> SETBIT y 1 1
  (integer) 0
  redis> SETBIT z 2 1  # z = 0000 0101
  (integer) 0
  redis> SETBIT z 0 1
  (integer) 0
  redis> BITOP AND and-result x y z    # 0000 0000
  (integer) 1
  redis> BITOP OR or-result x y z              # 0000 1111
  (integer) 1
  redis> BITOP XOR xor-result x y z    # 0000 1000
  (integer) 1
  ```

- 也可以对给定的位数组进行取反（not）运算：

  ------

  ```shell
  redis> SETBIT value 0 1                # 0000 1001
  (integer) 0
  redis> SETBIT value 3 1
  (integer) 0
  redis> BITOP NOT not-value value     # 1111 0110
  (integer) 1
  ```

### 位数组的表示

- Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。
- 图22-1展示了用SDS表示的，一字节长的位数组：
  - ·redisObject.type的值为REDIS_STRING，表示这是一个字符串对象。
  - ·sdshdr.len的值为1，表示这个SDS保存了一个一字节长的位数组。
  - ·buf数组中的buf[0]字节保存了一字节长的位数组。
  - ·buf数组中的buf[1]字节保存了SDS程序自动追加到值的末尾的空字符'\0'。

![image-20211209004223517](https://tva1.sinaimg.cn/large/008i3skNly1gx6wizxkcpj31520nkmyp.jpg)

### BITCOUNT命令的实现

- 遍历：实现BITCOUNT命令最简单直接的方法，就是遍历位数组中的每个二进制位，并在遇到值为1的二进制位时，将计数器的值增一。
- 查表算法：先创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量。我们可以根据输入的位数组进行查表，在无须对位数组的每个位进行检查的情况下，直接知道这个位数组包含了多少个值为1的二进制位

- variable-precision SWAR算法
  - BITCOUNT命令要解决的问题——统计一个位数组中非0二进制位的数量，在数学上被称为“计算汉明重量（Hamming Weight）”。
  - 目前已知效率最好的通用算法为variable-precision SWAR算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要使用任何额外的内存。

- Redis的实现：在执行BITCOUNT命令时，程序会根据未处理的二进制位的数量来决定使用那种算法：
  - ·如果未处理的二进制位的数量大于等于128位，那么程序使用variable-precision SWAR算法来计算二进制位的汉明重量。
  - ·如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重量。

## 第23章　慢查询日志

- Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。
- slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。
- slowlog-max-len选项指定服务器最多保存多少条慢查询日志。先进先出保存慢查询日志

```shell
redis> SLOWLOG GET
1) 1) (integer) 5
   2) (integer) 1378781521
   3) (integer) 61
   4) 1) "SLOWLOG"
      2) "GET"
2) 1) (integer) 4
   2) (integer) 1378781447
   3) (integer) 13
   4) 1) "SET"
      2) "database"
      3) "Redis"
3) 1) (integer) 3
   2) (integer) 1378781439
   3) (integer) 10
   4) 1) "SET"
      2) "number"
      3) "10086"
4) 1) (integer) 2
   2) (integer) 1378781436
   3) (integer) 18
   4) 1) "SET"
      2) "msg"
      3) "hello world"
5) 1) (integer) 1
   2) (integer) 1378781425
   3) (integer) 11
   4) 1) "CONFIG"
      2) "SET"
```

## 第24章　监视器

- 通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息：

  ```shell
  redis> MONITOR
  OK
  1378822099.421623 [0 127.0.0.1:56604] "PING"
  1378822105.089572 [0 127.0.0.1:56604] "SET" "msg" "hello world"
  1378822109.036925 [0 127.0.0.1:56604] "SET" "number" "123"
  1378822140.649496 [0 127.0.0.1:56604] "SADD" "fruits" "Apple" "Banana" "Cherry"
  1378822154.117160 [0 127.0.0.1:56604] "EXPIRE" "msg" "10086"
  1378822257.329412 [0 127.0.0.1:56604] "KEYS" "*"
  1378822258.690131 [0 127.0.0.1:56604] "DBSIZE"
  ```

  

- 每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器