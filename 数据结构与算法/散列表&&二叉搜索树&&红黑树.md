# 数据结构

## 基本概念

### 栈和队列

- 栈实现的一种后进先出（last-in，first-out，LIFO）策略；队列实现的是一种先进先出（FIFO）策略。

- 栈的 INSERT 操作称为 PUSH，而无参数的 DELETE 操作称为 POP，就像餐厅的一堆盘子，每次新增的盘子只能放在最上面，也只能从最上面拿走盘子。

- 可以用数组 S[1..n] 来实现一个最多可容纳 n 个元素的栈，该数组有个属性 S.top ，指向最新插入的元素，栈中包含的元素为 S[1..S.top] ，其中 S[1] 是栈底元素，而 S[S.top] 是栈顶元素。

- 如果试图对一个空栈执行 POP 操作，则称栈下溢（underflow），如果 S.top 超过了 n，则称栈上溢（overflow）。

- 队列的 INSERT 称为入队（ENQUEUE），DELETE 称为出队（DEQUEUE），就像银行排队的顾客，元素入队时只能放在队尾（tail），元素出队时只能从队头（head）出队。

- 与栈不同的是，队列在物理空间上的实现通常是一个环，即 1 好像紧邻在 n 后面，当 Q.head = Q.tail 时，队列为空，初始时 Q.head = Q.tail = 1。

- 下溢与上溢的定义与栈相同。

### 链表

- 见文章：[http://www.jianshu.com/p/3e236d392b79](http://www.jianshu.com/p/3e236d392b79)

### 二叉树

- 树的结点用对象表示，假设每个结点都含有一个关键字 key，那么我们可以利用属性 p、left、right 存放指向父节点、左孩子、右孩子的指针，如果 x.p = NIL，则 x 是根节点，同样的，如果 x.left = NIL ，则 x 没有左孩子。

- 二叉树的表示方法可以推广到每个结点的孩子数至多为常数 k 的任意类型的树：只需要将 left、right 属性用 child1、child2、child3 ... 代替，但是如果事先不知道孩子数呢？那样我们无法预先分配多少个属性，此外，如果将 k 限制在一个很大的常数内，但有部分结点只有少量的孩子，那显然是浪费空间的。

- 有个巧妙的办法可以解决上述问题，对于有 n 个结点的树，只需要 O(n) 的存储空间，这种叫做左孩子右兄弟表示法（left-child，right-sibling representation）。

- 和前述方法类似，每个结点都包含一个父节点 p，然而每个结点中不是包含指向每个孩子的指针，而是只有两个指针：

  - x.left-child 指向结点 x 最左边的孩子结点
  - x.right-sibling 指向 x 右侧相邻的兄弟结点

- 这样，如果 x 没有孩子结点，则 x.left-child = NIL；如果 x 是其父节点的最右孩子，则 x.right-sibling = NIL

## 散列表（hash table）

- 推荐几篇文章：

  - 学弟写的：[http://www.jianshu.com/p/dbe7a1ea5928](http://www.jianshu.com/p/dbe7a1ea5928)

  - [http://www.cnblogs.com/yangecnu/p/introduce-hashtable.html](http://www.cnblogs.com/yangecnu/p/introduce-hashtable.html)

### 关于 hash table 的一些概念

- 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

- 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。

- 哈希表是一种通过哈希函数将特定的键映射到特定值的一种数据结构，他维护者键和值之间一一对应关系。

- 键(key)：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分。

- 槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。

- 哈希函数(hash function)：将键(key)映射(map)到数据应该存放的槽(slot)所在位置的函数。

- 哈希冲突(hash collision)：哈希函数将两个不同的键映射到同一个索引的情况。

### 哈希冲突

- 因为直接寻址表（direct-address table）有可能导致两个关键字映射到同一个槽中，称之为哈希冲突，我们要找到办法解决这个问题。

- 第一种方法：拉链法(open hashing)

  > 《算法导论》中叫做链接法（chaining）

  - 用链表去拓展

- 第二种方法：开放寻址法(Open addressing 或 closing hashing)

  - 线性探测是开放寻址法的一种实现

  - 当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加 1。

  - 明显的缺点:数据很可能会聚集在一块，从而使得查找时间变长

  - 双重散列（double hashing）是最好的方法之一，因为它生成的排列具有随机选择排列的许多特性

## 二叉搜索树(BST)

- 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

  - 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

  - 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

  - 任意结点的左、右子树也分别为二叉查找树。

  - 没有键值相等的结点（no duplicate nodes）。

- 构建 BST （BST 排序）的时间复杂度：

  - 最坏情况/以排序：O(n^2)
  - 最好情况/平衡树：O(nlogn)
  - 时间复杂度与快速排序一样！
  - 因为原理和快速排序很像！
  - 做同样的比较，只是比较的顺序不同！
  - 随机化 BST 排序与随机化快速排序一样

- 树结点的平均深度为 logn，并不是树的高度就是 logn

- 但是，经过数学推导，随机化 BST 的高度期望就是 logn

- 对 BST 的三种遍历方式：

    - 中序遍历（inorder tree walk）：在二叉树中，先左后根再右。

    > 对 BST 进行中序遍历，可以实现排序的效果

    - 先序遍历（preorder tree walk）：根左右

    - 后序遍历（postorder tree walk）：左右根

- 假设二叉搜索树的高度为 h，那么它支持任何一种基本动态集合操作，如 SEARCH,PREDECESSOR,SUCCESSOR,MINIMUM,MAXIMUM,INSERT,DELETE，且时间复杂度均为 O(h)。

- 二叉搜索树的插入：

  - 如果要在二叉查找树中插入一个结点，首先要查找到结点插入的位置，然后进行插入，假设插入的结点为z的话，插入的伪代码如下：

        TREE-INSERT(T, z)
        1  y ← NIL
        2  x ← root[T]
        3  while x ≠ NIL
        4      do y ←  x
        5         if key[z] < key[x]
        6            then x ← left[x]
        7            else x ← right[x]
        8  p[z] ← y
        9  if y = NIL
        10     then root[T] ← z              ⊹ Tree T was empty
        11     else if key[z] < key[y]
        12             then left[y] ← z
        13             else right[y] ← z

- 二叉搜索树的删除：

  - 删除分为三种情况：

    - 如果z没有孩子结点，那么只是简单地将它删除，并修改它的父节点，用NIL来替换z
    - 如果z只有一个孩子，那么用它代替z即可
    - 如果z有两个孩子，那么找z的后继y（肯定在z的右子树中），并让y占据树中z的位置，这种情况有点麻烦，因为还要确定y是否是z的右孩子

- 具体过程可去这个网站学习：[https://visualgo.net/en/bst](https://visualgo.net/en/bst)

        TREE-DELETE(T, z)
        1  if left[z] = NIL or right[z] = NIL
        2      then y ← z
        3      else y ← TREE-SUCCESSOR(z)
        4  if left[y] ≠ NIL
        5      then x ← left[y]
        6      else x ← right[y]
        7  if x ≠ NIL
        8      then p[x] ← p[y]
        9  if p[y] = NIL
        10      then root[T] ← x
        11      else if y = left[p[y]]
        12              then left[p[y]] ← x
        13              else right[p[y]] ← x
        14  if y ≠ z
        15      then key[z] ← key[y]
        16           copy y's satellite data into z
        17  return y

## 红黑树

> 推荐阅读：[http://www.cnblogs.com/v-July-v/archive/2010/12/29/1983707.html](http://www.cnblogs.com/v-July-v/archive/2010/12/29/1983707.html)

- 如果二叉搜索树的高度较高，那么某些集合操作可能并不比在链表上执行得快，红黑树（red-black tree）是许多“平衡”搜索树的一种，红黑树保证了：一棵 n 个结点的红黑树的高度始终保持在 h = logn，因此可以保证在最坏情况下基本动态集合操作的时间复杂度为O(lgn)。

- 红黑树在每个结点上增加了一个存储为来表示结点的颜色，RED or BLACK，且有这样的约束：没有任何一条路径会比其他路径长两倍。

- 红黑树的性质：

  1. 每个结点或是红色或是黑色
  1. 根结点是黑色的
  1. 每个叶结点（NIL）是黑色的
  1. 如果一个结点是红色的，则它的两个子结点都是黑色的（也可以这样理解：每个红色结点的父结点都是黑色结点）
  1. 对每个结点，从该结点到起所有后代叶结点的简单路径上，均包含相同数目的黑色结点

- 定义：黑高（black-hight），记为 bh(x)，从某个结点 x 出发（不含该结点），到达一个叶结点的任意一条简单路径上的黑色结点数称为该结点的黑高。

  > 因为性质5，所以黑高是确定的

### 旋转

- 当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。

- 为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后，继续保持它的性质或平衡。

- 树的旋转，分为左旋和右旋，以下借助图来做形象的解释和介绍：

  ![2017918-leftrotate](http://ooy7h5h7x.bkt.clouddn.com/blog/image/2017918-leftrotate.jpg)

- 如上图所示：

- 当在某个结点pivot上，做左旋操作时，我们假设它的右孩子y不是NIL[T]，pivot可以为任何不是NIL[T]的左孩子结点。

- 左旋以pivot到y之间的链为“支轴”进行，它使y成为该孩子树新的根，而y的左孩子b则成为pivot的右孩子。

- 左旋操作的参考代码如下所示（以x代替上述的pivot）：

        LEFT-ROTATE(T, x)  
        1  y ← right[x] ▹ Set y.  
        2  right[x] ← left[y]      ▹ Turn y's left subtree into x's right subtree.  
        3  p[left[y]] ← x  
        4  p[y] ← p[x]             ▹ Link x's parent to y.  
        5  if p[x] = nil[T]  
        6     then root[T] ← y  
        7     else if x = left[p[x]]  
        8             then left[p[x]] ← y  
        9             else right[p[x]] ← y  
        10  left[y] ← x             ▹ Put x on y's left.  
        11  p[x] ← y  

- 右旋示意图

  ![2017918-rightrotate](http://ooy7h5h7x.bkt.clouddn.com/blog/image/2017918-rightrotate.jpg)

- 右旋与左旋差不多，反过来就是，在此不做详细介绍。