# 排序算法

- 冒泡排序

- 选择排序

- 插入排序

- 快速排序（最常见）

- 希尔排序

- 归并排序

> 源码：[Sorting](https://github.com/edisonleolhl/DataStructure-Algorithm/blob/master/Sorting)

## 冒泡排序

- 冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

- 冒泡排序算法的思路如下（升序）：

  - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  - 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
  - 针对所有的元素重复以上的步骤，除了最后一个。
  - 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

- 冒泡排序的分析

    ![bubblesort](http://upload-images.jianshu.io/upload_images/2106579-374cb53dfbe2de9f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 演示

    ![bubble](http://upload-images.jianshu.io/upload_images/2106579-2f459b9a6fa2262d.gif?imageMogr2/auto-orient/strip)

- 时间复杂度

  - 最优时间复杂度：O(n) ——表示遍历一次发现没有任何可以交换的元素，排序结束
  - 最坏时间复杂度：O(n2)
  - 稳定性：稳定

- Python 代码

        def bubble_sort(L):
            N = len(L)
            if N <= 0 :
                print("Please input correct list.")
                return
            for i in range(N):
                for j in range(0,N-1-i):
                    if L[j] > L[j+1] :
                        L[j],L[j+1] = L[j+1],L[j]
                        print(L)
            return L

        if __name__ == '__main__':
            L = [9,8,7,6,5,4,3,2,1]
            print(bubble_sort(L))

- 输出

        >>>
        RESTART: F:\杂\markdown\Python\DataStructure&Algorithm\Sorting\bubble_sort.py
        [8, 9, 7, 6, 5, 4, 3, 2, 1]
        [8, 7, 9, 6, 5, 4, 3, 2, 1]
        [8, 7, 6, 9, 5, 4, 3, 2, 1]
        [8, 7, 6, 5, 9, 4, 3, 2, 1]
        [8, 7, 6, 5, 4, 9, 3, 2, 1]
        [8, 7, 6, 5, 4, 3, 9, 2, 1]
        [8, 7, 6, 5, 4, 3, 2, 9, 1]
        [8, 7, 6, 5, 4, 3, 2, 1, 9]
        [7, 8, 6, 5, 4, 3, 2, 1, 9]
        [7, 6, 8, 5, 4, 3, 2, 1, 9]
        [7, 6, 5, 8, 4, 3, 2, 1, 9]
        [7, 6, 5, 4, 8, 3, 2, 1, 9]
        [7, 6, 5, 4, 3, 8, 2, 1, 9]
        [7, 6, 5, 4, 3, 2, 8, 1, 9]
        [7, 6, 5, 4, 3, 2, 1, 8, 9]
        [6, 7, 5, 4, 3, 2, 1, 8, 9]
        [6, 5, 7, 4, 3, 2, 1, 8, 9]
        [6, 5, 4, 7, 3, 2, 1, 8, 9]
        [6, 5, 4, 3, 7, 2, 1, 8, 9]
        [6, 5, 4, 3, 2, 7, 1, 8, 9]
        [6, 5, 4, 3, 2, 1, 7, 8, 9]
        [5, 6, 4, 3, 2, 1, 7, 8, 9]
        [5, 4, 6, 3, 2, 1, 7, 8, 9]
        [5, 4, 3, 6, 2, 1, 7, 8, 9]
        [5, 4, 3, 2, 6, 1, 7, 8, 9]
        [5, 4, 3, 2, 1, 6, 7, 8, 9]
        [4, 5, 3, 2, 1, 6, 7, 8, 9]
        [4, 3, 5, 2, 1, 6, 7, 8, 9]
        [4, 3, 2, 5, 1, 6, 7, 8, 9]
        [4, 3, 2, 1, 5, 6, 7, 8, 9]
        [3, 4, 2, 1, 5, 6, 7, 8, 9]
        [3, 2, 4, 1, 5, 6, 7, 8, 9]
        [3, 2, 1, 4, 5, 6, 7, 8, 9]
        [2, 3, 1, 4, 5, 6, 7, 8, 9]
        [2, 1, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        >>>

## 选择排序

- 选择排序（Selection sort）是一种简单直观的排序算法。

- 它的工作原理如下：

  - 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
  - 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
  - 以此类推，直到所有元素均排序完毕。

- 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

- 选择排序分析

    ![selectionsort](http://upload-images.jianshu.io/upload_images/2106579-f481b95b4babba7c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 演示

    ![selection](http://upload-images.jianshu.io/upload_images/2106579-5529baa19c386a22.gif?imageMogr2/auto-orient/strip)

- 时间复杂度

  - 最优时间复杂度：O(n2)
  - 最坏时间复杂度：O(n2)
  - 稳定性：不稳定（考虑升序每次选择最大的情况）

- Python 代码

        def select_sort(L):
            N = len(L)
            if N <= 0 :
                print("Please input correct list.")
                return
            for i in range(N-1):
                indexOfMax = 0
                for j in range(1,N-i):
                    if L[j] > L[indexOfMax] :
                        indexOfMax = j
                L[N-1-i], L[indexOfMax] = L[indexOfMax], L[N-1-i]
                print(L)
            return L

        if __name__ == '__main__':
            L = [9,8,7,6,5,4,3,2,1]
            select_sort(L)

- 输出

        >>>
        RESTART: F:/杂/markdown/Python/DataStructure&Algorithm/Sorting/selection_sort.py
        [1, 8, 7, 6, 5, 4, 3, 2, 9]
        [1, 2, 7, 6, 5, 4, 3, 8, 9]
        [1, 2, 3, 6, 5, 4, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        >>>

## 插入排序

- 插入排序（Insertion Sort）是一种简单直观的排序算法，对于少量元素，它是一种有效的算法（一般30个元素以下）。

- 想像一下，我们在打扑克牌，首先我们手上没有牌，然后一张一张从桌上摸牌，每次摸牌都会按照从小到大的顺序排好，所以手上的牌总是有序的。

- 它的工作原理：

  - 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
  - 插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

- 演示

    ![Insertion-sort-example](http://upload-images.jianshu.io/upload_images/2106579-1596925c0a807ad4.gif?imageMogr2/auto-orient/strip)

- 伪代码

        INSERTION-SORT(A)
            for j = 2 to A.length
                key = A[j]
                //Insert A[j] into the sorted sequence A[1..j-1].
                i = j - 1
                while i > 0 and A[i] > key
                    A[i+1] = A[i]
                    i = i - 1
                A[i+1] = key

- 时间复杂度

  - 最优时间复杂度：O(n) ——升序排列，序列已经处于升序状态
  - 最坏时间复杂度：O(n2) ——序列处于降序状态，要转变为升序
  - 稳定性：稳定

- Python 代码

        def insertion_sort(L):
            N = len(L)
            if N <= 0:
                print("Please input correct list.")
                return
            for i in range(1, N): # i指示当前待排元素，初始时，把L[0]加入已排序列
                temp = L[i]
                for j in range(i-1, -1, -1): # i-1指示已排序列的最后一项，然后以此与当前待排元素比较，往前移动
                    if L[j] <= temp:
                        L[j+1] = temp
                    else:
                        L[j+1] = L[j]
                        if j == 0:
                            L[j] = temp
            return L

        def insertion_sort_desc(L):
            N = len(L)
            if N <= 0:
                print("Please input correct list.")
                return
            for i in range(1, N):
                temp = L[i]
                for j in range(i-1, -1, -1):
                    if L[j] >= temp:
                        L[j+1] = temp
                    else:
                        L[j+1] = L[j]
                        if j == 0:
                            L[j] = temp
            return L

        if __name__ == '__main__':
            L = [2, 8, 7, 6, 5, 4, 3, 2, 1]
            print("ordered sequence =", insertion_sort(L))
            print("ordered sequence descending = ", insertion_sort_desc(L))

- 输出

        ordered sequence = [1, 2, 2, 3, 4, 5, 6, 7, 8]
        ordered sequence descending =  [8, 7, 6, 5, 4, 3, 2, 2, 1]

## 快速排序（最常见）

- 使用分治策略（divide and conquer）

- 原地排序（不需要额外辅助空间）

- 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

- 步骤为：

  - 从数列中挑出一个元素，称为"基准"（pivot），或称枢纽
  - 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
  - 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
  - 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

- 时间复杂度

  - 最优时间复杂度：O(nlogn)
  - 最坏时间复杂度：O(n^2) ——每次分区时，某个分区为空(即数组已排序或者已倒序)
  - 平均时间复杂度：O(nlogn)
  - 稳定性：不稳定

- 从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。

- 在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。

- 那么为什么平均时间复杂度也是 O(nlogn) 呢？实际上，任何一种常数比例的划分都会产生 Θ(lgn) 的递归树，其中每一层的时间代价都是 O(n)。因此，只要划分是常数比例的，算法的运行时间总是 O(nlgn)。（具体证明见《算法导论》）

- Python 代码

        def quick_sort(L,low,high):
            if(low < high):
                pivotloc = partition(L,low,high)
                quick_sort(L,low,pivotloc-1)
                quick_sort(L,pivotloc+1,high)
            return L


        def partition(L,low,high):
            if(low >= high):
                return
            pivotkey = L[low]
            while(low < high):
                while(low < high and L[high] >= pivotkey):
                    high = high - 1
                L[low],L[high] = L[high],L[low]
                while(low < high and L[low] <= pivotkey):
                    low = low + 1
                L[high],L[low] = L[low],L[high]
                print("pivotkey =",pivotkey)
                print(L,"\n")
            return low

        if __name__ == '__main__':
            L = [1,8,7,6,5,4,3,2,1]
            print(quick_sort(L, 0, len(L)-1))

- 输出

        pivotkey = 1
        [1, 8, 7, 6, 5, 4, 3, 2, 1] 

        pivotkey = 8
        [1, 1, 7, 6, 5, 4, 3, 2, 8] 

        pivotkey = 1
        [1, 1, 7, 6, 5, 4, 3, 2, 8] 

        pivotkey = 7
        [1, 1, 2, 6, 5, 4, 3, 7, 8] 

        pivotkey = 2
        [1, 1, 2, 6, 5, 4, 3, 7, 8] 

        pivotkey = 6
        [1, 1, 2, 3, 5, 4, 6, 7, 8] 

        pivotkey = 3
        [1, 1, 2, 3, 5, 4, 6, 7, 8] 

        pivotkey = 5
        [1, 1, 2, 3, 4, 5, 6, 7, 8] 

        [1, 1, 2, 3, 4, 5, 6, 7, 8]

- 《算法导论》的另一种解法：PARTITION 过程按从左往右对数组进行操作。

        PARTITION(A, p, r)
        1  x = A[r]
        2  i = p - 1
        3  for j = p to r - 1
        4      if A[j] ≤ x
        5          i = i + 1
        6          exchange A[i] with A[j]
        7  exchange A[i+1] with A[r]
        8  return i + 1

- 在算法中引入随机性，可以使得算法对于所有的输入都能有较好的期望，比如如果输入的是已排序/已倒序的输入，那么通过随机打乱数组或者随机选择 pivot，就可以不会让算法的效率变低。

- 随机抽样（random sampling）就是这种策略，可以保证 pivot 是随机地从数组中选取的，我们期望在平均情况下对输入数组的划分是比较均衡的。

- RANDOMIZED-QUICKSORT 一般比普通的 QUICKSORT 速度更快，尽量多用。

> 问题一：对n个记录的线性表进行快速排序,为减少算法的递归深度,每次分区后,应先处理较短的部分
>
>在快速排序中，需要使用递归来分别处理左右子段，递归深度可以理解为系统栈保存的深度,先处理短的分段再处理长的分段，可以减少时间复杂度；
>如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，长的递归调用没有进行，他是作为一个整体保存在栈中的，所以递归栈中的保留的递归数据少一些。
>
> 问题二：采用递归方式对顺序表进行快速排序，递归次数与每次划分后得到的分区处理顺序无关
>
> 递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。

## 希尔排序

- 希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

- 基本思想：先将整个待排序列分割称为若干子序列分别进行直接插入排序，待整个序列“基本有序”时，再对全体记录进行一次直接插入排序

- 希尔排序过程

  - 希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

  - 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：

        13 14 94 33 82
        25 59 94 65 23
        45 27 73 25 39
        10

    然后我们对每列进行排序：

        10 14 73 25 23
        13 27 94 33 39
        25 59 94 65 82
        45

    将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：

        10 14 73
        25 23 13
        27 94 33
        39 25 59
        94 65 82
        45

    排序之后变为：

        10 14 13
        25 23 33
        27 25 59
        39 65 73
        45 94 82
        94

    最后以1步长进行排序（此时就是简单的插入排序了）

- 时间复杂度

  - 最优时间复杂度：根据步长序列的不同而不同
  - 最坏时间复杂度：O(n2)
  - 稳定性：不稳定

- Python 代码

        def shell_sort(L,delta):
            N = len(L)
            for inc in delta:
                L = shell_insert(L,inc)
                print(L,"\n")
            return L

        def shell_insert(L,inc):
            N = len(L)
            for index in range(inc):               # 整个序列分为若干子序列，index是每个子序列的头元素
                for i in range(index+inc,N,inc):   # 默认每个子序列的头元素为“已排序列”，除了头元素的子序列为“待排序列”
                    temp = L[i]                    # 每个子序列的排序方式为直接插入排序，所以当前待排元素的值给temp
                    for j in range(i-inc,-1,-inc): # 在子序列的“已排序列”中找到合适的插入地点，所以是倒序
                        if temp < L[j]:
                            L[j+inc] = L[j]
                        else :
                            break                  # 当前待排元素比“已排序列”中的末尾元素还要大，所以直接放入末尾
                        if j == index or L[j-inc] < temp :
                            L[j] = temp
                            print(L)
            return L

        if __name__ == '__main__':
            L = [9,8,7,6,5,4,3,2,1]
            delta = [5,3,1] #构造增量序列
            print(shell_sort(L,delta))

- 输出

        >>>
        RESTART: F:\杂\markdown\Python\DataStructure&Algorithm\Sorting\shell_sort.py
        [4, 8, 7, 6, 5, 9, 3, 2, 1]
        [4, 3, 7, 6, 5, 9, 8, 2, 1]
        [4, 3, 2, 6, 5, 9, 8, 7, 1]
        [4, 3, 2, 1, 5, 9, 8, 7, 6]
        [4, 3, 2, 1, 5, 9, 8, 7, 6]

        [1, 3, 2, 4, 5, 9, 8, 7, 6]
        [1, 3, 2, 4, 5, 6, 8, 7, 9]
        [1, 3, 2, 4, 5, 6, 8, 7, 9]

        [1, 2, 3, 4, 5, 6, 8, 7, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        [1, 2, 3, 4, 5, 6, 7, 8, 9]

        [1, 2, 3, 4, 5, 6, 7, 8, 9]
        >>>

## 归并排序

- 归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。

- 将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。

- 归并排序的分析

    ![Merge-sort-example](http://upload-images.jianshu.io/upload_images/2106579-0795cb9edc24d9ca.gif?imageMogr2/auto-orient/strip)

- 时间复杂度

  - 最优时间复杂度：O(nlogn)
  - 最坏时间复杂度：O(nlogn)
  - 稳定性：稳定
  - 缺点:占用了一定的空间，所以归并算法是用空间换取时间的典型应用

    > 一分为二，一分为二，总共有 logn 个分离操作
    >
    > 合并两个子程序需要时间为 n
    >
    > 合起来所以时间复杂度为 θ(nlogn)

- Python 代码

        def merge(left, right):
            lp, rp = 0, 0
            result = []
            while lp < len(left) and rp < len(right):
                if left[lp] <= right[rp]:
                    result.append(left[lp])
                    lp += 1
                else:
                    result.append(right[rp])
                    rp += 1
            result += left[lp:]
            result += right[rp:]
            return result

        def merge_sort(alist):
            length = len(alist)
            if length == 1:
                return alist
            mid = length // 2
            left = merge_sort(alist[:mid])
            right = merge_sort(alist[mid:])
            print("left = %s, right = %s"%(left,right))
            result = merge(left, right)
            print("merge:",result)
            return result

        if __name__ == '__main__':
            alist = [9, 8, 7, 6, 5, 4, 3, 2, 1]
            print("ordered sequence =",merge_sort(alist))

- 输出

        left = [9], right = [8]
        merge: [8, 9]
        left = [7], right = [6]
        merge: [6, 7]
        left = [8, 9], right = [6, 7]
        merge: [6, 7, 8, 9]
        left = [5], right = [4]
        merge: [4, 5]
        left = [2], right = [1]
        merge: [1, 2]
        left = [3], right = [1, 2]
        merge: [1, 2, 3]
        left = [4, 5], right = [1, 2, 3]
        merge: [1, 2, 3, 4, 5]
        left = [6, 7, 8, 9], right = [1, 2, 3, 4, 5]
        merge: [1, 2, 3, 4, 5, 6, 7, 8, 9]
        ordered sequence = [1, 2, 3, 4, 5, 6, 7, 8, 9]

## 各种排序算法效率比较

![2017911-排序比较](http://ooy7h5h7x.bkt.clouddn.com/blog/image/2017911-排序比较.jpg)

- 算法是否稳定：待排序列中同样元素的先后顺序是否改变

  比如待排序列是：2，3，1，8，9，1'

  排列后的序列是：1'，1，2，3，8，9

- 快速排序应用广泛的原因：

  - 性能接近 O(nlogn)

  - 辅助空间较归并排序小

  - 一般不太关注稳定与否

---
> 之前讨论的排序算法都有一个有趣的性质：各元素的次序依赖于它们之间的比较结果，我们称之为比较排序。
>
> 比较排序在最坏情况下都要经过 Ω(nlgn) 次比较，因此归并排序与堆排序是渐进最优的，并且任何已知的比较排序最多就是在常熟因子上优于它们。
>
> 接下来要介绍的就不是比较排序模型了，它们可以实现线性时间内完成排序。

## 计数排序

- 计数排序假设 n 个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当 k=O(n) 时，排序的运行时间为 Θ(n)。

- 假设输入的数组为 A[1..n] ，计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。最后还需要一个数组 B 来输出。

- 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存.

- 通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：

  - 找出待排序的数组中最大和最小的元素
  - 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项
  - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
  - 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

- 时间复杂度：O(n+k)，k 就是待排数组的最大整数，这说明数组中的值很小时，计数排序运行很快，但是当数据范围很大的数组，计数排序就比较慢了。

- 计数排序的一个重要性质就是它是稳定的：具有相同值的元素z唉输出数组中的相对次序与它们在输入数组中的相对次序相同。一般来说，这种稳定性只有当待排数据还附带卫星数据时才有用，计数排序经常作为基数排序的一个子过程，并且必须要求计数排序是稳定的。

## 基数排序

- 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。

- 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，每轮都按照当前位数对所有数据进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

- 注意，每轮的排序得采用稳定排序，比如计数排序就是不错的子过程。

- 时间复杂度: O(kn)，其中 n 是排序元素个数， k 是数字位数。注意这不是说这个时间复杂度一定优于 O(nlogn)，  k 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；  k 决定了进行多少轮处理，而  n 是每轮处理的操作数目。

## 桶排序

- 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。

- 桶排序假设输入服从均匀分布，平均时间下它的时间代价为 O(n) ，与计数排序类似，因为对输入数据做了假设，所以桶排序的速度很快。

- 桶排序以下列程序进行：

  - 设置一个定量的数组当作空桶子。
  - 寻访序列，并且把项目一个一个放到对应的桶子去。
  - 对每个不是空的桶子进行排序。
  - 从不是空的桶子里把项目再放回原来的序列中。

- 伪代码：

        function bucket-sort(array, n) is
        buckets ← new array of n empty lists
        for i = 0 to (length(array)-1) do
            insert array[i] into buckets[msbits(array[i], k)]
        for i = 0 to n - 1 do
            next-sort(buckets[i])
        return the concatenation of buckets[0], ..., buckets[n-1]