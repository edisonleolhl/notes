# 贪心算法（greedy algorithm）与回溯算法（backtracking）

## 尾递归优化

- 链接：https://www.nowcoder.com/questionTerminal/c7c14a2d52ea458c95fed1e6198ca4e8
来源：牛客网

- 尾递归：在每一次递归的过程中保持了上一次计算的状态，也就是“线性迭代过程”

- 尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）

- 在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出

      普通的递归版本
      int fab(int n){
          if(n<3)
              return 1;
          else
              return fab(n-1)+fab(n-2);
      }

      具有"线性迭代过程"特性的递归---尾递归过程
      int fab(int n,int b1=1,int b2=1,int c=3){
          if(n<3)
              return 1;
          else {
              if(n==c)
                  return b1+b2;
              else
                  return fab1(n,b2,b1+b2,c+1);
          }
      }

- 以fab(4)为例子

      普通递归fab(4)=fab(3)+fab(2)=fab(2)+fab(1)+fab(2)=3  6次调用
      尾递归fab(4,1,1,3)=fab(4,1,2,4)=1+2=3                         2次调用

## 贪心算法简介

- 求解最优化问题的算法通常需要一系列的步骤，在每个步骤前都面临各种选择。

- 对于许多优化问题，使用动态规划来求最优解有点大材小用，可以使用更简单更高效的贪心算法。

- 贪心算法在每一步都会做出当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能达到全局最优。

## 回溯算法

- 回溯算法实际上一个类似枚举的搜索尝试过程，区别是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径，可以系统地搜索一个问题的一个解或者所有解。

- 回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。

- 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

  1. 找到一个可能存在的正确的答案。
  1. 在尝试了所有可能的分步方法后宣告该问题没有答案。

- 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

- 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

