# 设计模式之美



## 面向对象

### 概述

- 面向对象的四大特性：封装、抽象、继承、多态
- **按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言**

- 面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程

### 四大特性解决什么问题

- 封装（Encapsulation）：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据
- 抽象（Abstraction）： 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
  - 不一定非要编写接口类才叫抽象，单纯的类本身就是满足抽象特性的，通过函数对外提供函数签名，调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。
- 继承（Inheritance）：继承是用来表示类之间的is-a关系，为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用<。不过，有些编程语言只支持单继承，不支持多重继承，比如Java、PHP、C#、Ruby等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl等
  - 继承最大的一个好处就是代码复用

- 多态（Polymorphism）：多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

  - 三种实现方法：

    - 继承加方法重写：编程语言要支持父类对象可以引用子类对象&&编程语言要支持继承&&编程语言要支持子类可以重写（override）父类中的方法

    - 接口类：class xxx implement interface，C++不支持接口类，Java支持接口类

    - duck-typing：只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，只有一些动态语言如Python、JavaScript才支持

      ```python
      class Logger:
          def record(self):
              print(“I write a log into file.”)
              
      class DB:
          def record(self):
              print(“I insert data into db. ”)
              
      def test(recorder):
          recorder.record()
      
      def demo():
          logger = Logger()
          db = DB()
          test(logger)
          test(db)
      ```

  - 多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等

### 面向对象vs面向过程

- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。
- 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。
- 面向对象比面向过程有哪些优势？
  - OOP更加能够应对大规模复杂程序的开发
  - OOP风格的代码更易复用、易扩展、易维护
  - OOP语言更加人性化、更加高级、更加智能

### 哪些代码看似面向对象实则面向过程

- 滥用getter、setter方法
- 滥用全局变量和全局方法
  - Constants类可拆分为更细化的多个类，如MySqlConstants类、RedisConstants类
  - Utils类也可拆分，只包含静态方法不包含任何属性的Utils类，是彻彻底底的面向过程的编程风格，但我们不排斥这种面向过程的编程风格

- 定义数据和方法分离的类
  - 如MVC贫血模型
- 我们之所以容易写出面向过程风格的代码，是因为与我们的大脑顺序思考的结果有关。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。

### 接口vs抽象类

- 并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++这种编程语言只支持抽象类，不支持接口；而像Python这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。
- 抽象类特点（以Java为例）
  - 抽象类不允许被实例化，只能被继承。也就是说，你不能new一个抽象类的对象出来
  - 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。
  - 子类继承抽象类，必须实现抽象类中的所有抽象方法

- 接口特点（以Java为例）
  - 接口不能包含属性（也就是成员变量）。
  - 接口只能声明方法，方法不能包含代码实现。
  - 类实现接口的时候，必须实现接口中声明的所有方法。

- 理解：抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种is-a的关系，那抽象类既然属于类，也表示一种is-a的关系。相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

- 抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。
- 实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。

- C++没有接口，但可以通过抽象类来模拟接口，

  ```c++
  // 抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。
  class Strategy { // 用抽象类模拟接口
    public:
      ~Strategy();
      virtual void algorithm()=0;
    protected:
      Strategy();
  };
  ```

- Java可以用普通类模拟接口，

  ```java
  // 普通类的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出MethodUnSupportedException异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。
  public class MockInteface {
    protected MockInteface() {}
    public void funcA() {
      throw new MethodUnSupportedException();
    }
  }
  ```

- 如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示_x0008_一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。

### 基于接口而非实现编程

- Program to an interface, not an implementation
- 这里的接口不是指interface语法的接口，事实上，这条原则最早出现于1994年GoF的《设计模式》，比很多编程语言如Java都还要诞生得早

- 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。

- **越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。**而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。
- 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

### 多用组合少用继承

- 虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。
- 比如，大部分的鸟都会飞，但如果在抽象鸟类中定义fly()方法，所有鸟（如燕子、鸽子、鸵鸟）都要重写fly()方法，但是鸵鸟不会飞，这就需要将抽象鸟类细化成抽象的会飞鸟类与抽象的不会飞鸟类，如果此时还有『是否会叫』，『是否会下蛋』，继承层次就会越来越深了

- 可以使用组合（composition）、接口、委托（delegation）解决继承的问题

  ```java
  public interface Flyable {
    void fly()；
  }
  public class FlyAbility implements Flyable {
    @Override
    public void fly() { //... }
  }
  //省略Tweetable/TweetAbility/EggLayable/EggLayAbility
  
  public class Ostrich implements Tweetable, EggLayable {//鸵鸟
    private TweetAbility tweetAbility = new TweetAbility(); //组合
    private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
    //... 省略其他属性和方法...
    @Override
    public void tweet() {
      tweetAbility.tweet(); // 委托
    }
    @Override
    public void layEgg() {
      eggLayAbility.layEgg(); // 委托
    }
  }
  ```

- 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

- 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

### 贫血模型的MVC架构违背OOP吗

- 在贫血模型中，数据和业务逻辑被分割到不同的类中。**充血模型**（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
- MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑
- 在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。

- 为什么贫血模型的传统开发模式受欢迎？
  - 业务简单，贫血模型应付足矣
  - 充血模型设计更有难度
  - 思维固化，转型有成本

- 平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。
- 基于充血模型的DDD的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

- 复杂的系统对代码复用性、可扩展性、可维护性要求更高，应该花更多精力在前期设计上，DDD正好需要前期大量调研

### 充血模型

- **在基于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类变得很薄，但并没有完全删除Service类，这是因为：**
  - Service类负责与Repository交流，领域模型不应与其他层代码（如Repo层）耦合在一起
  - Service类负责跨领域模型的业务聚合功能
  - Service类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC接口等，都可以放到Service类中。

- Service层充血了，Controller层与Repository层是否也需要充血？
  - 没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多

### 面向对象设计和编程——方法论

1. **划分职责进而识别出有哪些类**

   根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

2. **定义类及其属性和方法**

   我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

3. **定义类与类之间的交互关系**

   UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

4. **将类组装起来并提供执行入口**

   我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。

## 设计原则

### 单一职责

- A class or module should have a single responsibility
- 不要设计大而全的类，要设计粒度小、功能单一的类

- 举例，社交产品中UserInfo类是否满足单一职责原则呢？

  ```java
  public class UserInfo {
    private long userId;
    private String username;
    private String email;
    private String telephone;
    private long createTime;
    private long lastLoginTime;
    private String avatarUrl;
    private String provinceOfAddress; // 省
    private String cityOfAddress; // 市
    private String regionOfAddress; // 区 
    private String detailedAddress; // 详细地址
    // ...省略其他属性和方法...
  }
  ```

  - 一种观点是，UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；
  - 另一种观点是，地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的UserAddress类，UserInfo只保留除Address之外的其他信息，拆分之后的两个类的职责更加单一
  - 进一步延伸，如果社交平台发展成电商平台，就需要物流信息，地址最好拆分出来
  - 再延伸，公司开发了其他产品，希望支持统一账号系统，身份认证相关的信息如email、telephone等也可以抽取出来成独立的类

- 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的

- 最佳实践：
  - **先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，可以考虑拆分**
  - 类中的代码行数、函数或属性过多时
  - 类依赖的其他类过多，或者依赖类的其他类过多时
  - 私有方法过多时
  - 比较难给类起一个合适名字，很难用一个业务名词概括时
  - 类中大量的方法都是集中操作类中的某几个属性时

### 开闭原则

- Open Closed Principle：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification
- 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

- 添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则

- 最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，可以做事先做扩展性设计

### 里式替换原则

- If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
- Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
- 理解：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

- 多态和里式替换有点类似，但它们关注的角度是不一样的
  - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。
  - 里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

- 里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。

- 违反里式替换原则的例子：
  - 违反父类声明的功能：父类提供sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个函数之后，是按照创建日期来给订单排序的
  - 违反父类对输入/输出/异常的约定：父类某个函数运行出错的时候返回null，子类重写运行出错返回异常
  - 违反父类注释中所罗列的任何特殊说明：父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额

- 简单验证：拿父类的单元测试去验证子类的代码，如果有失败，则有可能违背里式替换原则

### 接口隔离原则

- Interface Segregation Principle”，缩写为ISP，Clients should not be forced to depend upon interfaces that they do not use
- 把“接口”理解为一组API接口集合，比如用户服务这组API接口是对外提供的，鉴权用户这组API接口是对内（后台管理人员）提供的，这就符合接口隔离原则
- 把“接口”理解为单个API接口或函数，函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
- 把“接口”理解为OOP中的接口概念，接口粒度要小
- 与单一职责原则的区别：单一职责原则针对的是模块、类、接口的设计，接口隔离原则更侧重于接口的设计

### 依赖反转

- 控制反转的英文翻译是Inversion Of Control，缩写为IOC，是一种设计思想，这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
  - 实现控制反转的方式有很多，除了依赖注入，还有模板模式等

- 依赖注入的英文翻译是Dependency Injection，缩写为DI，是一种具体的编程技巧，具体指：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。**提高了代码的扩展性**
- 依赖注入框架，比如Google Guice、Java Spring、Pico Container、Butterfly Container等，Spring框架是**控制反转容器**（Inversion Of Control Container）

- 依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP，High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

### KISS&YAGNI

- keep it simple and stupid，尽可能简单
- 并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等
- 比如解决文本字符串匹配问题，KMP算法虽然非常复杂，但文本字符串匹配问题本身就很复杂，所以KMP算法仍然是满足KISS原则的，

- YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它，不要过度设计
  - 比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。
- KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）

### DRY与复用性

- Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。

- 举例：
  - 实现逻辑重复：有两个一模一样的校验用户账号与密码的函数，其实并不违反DRY，因为账号与密码以后可能会有不同的逻辑，但重复的代码片段可以抽出公共函数
  - 功能语义重复：有isValidIp()和checkIfIpValid()两个函数，都是用来校验IP是否合法的，所以违反了DRY
  - 代码执行重复：比如多次鉴权判断，如果是IO，非常耗时

### 迪米特法则与高内聚、低耦合

- “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。
- 高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。**单一职责原则是实现高内聚的有效手段之一**

- 松耦合，类与类之间的依赖关系简单清晰，依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了松耦合

- Law of Demeter，缩写是LOD，The Least Knowledge Principle，Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.

- **如何理解“迪米特法则”？**

  不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

### 实战

#### 为什么要MVC分层

1. 分层能起到代码复用的作用
2. 分层能起到隔离变化的作用
3. 分层能起到隔离关注点的作用
4. 分层能提高代码的可测试性
5. 分层能应对系统的复杂性

#### BO、VO、Entity的意义

- 针对Controller、Service、Repository三层，每层都会定义相应的数据对象，它们分别是VO（View Object）、BO（Business Object）、Entity

- VO、BO、Entity三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背DRY原则。在前面讲到DRY原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。
- 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！

### 如何开发复杂系统

- 对业务系统，可以从已有项目架构中借鉴，然后从一个用户用例出发，思考如何搭建
- 对于非业务系统，可以搭建最小原型，快速地run起来，这是迭代的基础

## 规范与重构

### 重构概述

- 软件设计大师Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”

- “初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”

- 持续重构：作为开发的一部分，代码质量总会存在不完美，重构就会持续进行

### 如何保证重构不出错

- 最有效的手段就是单元测试，如果新的代码仍然能通过所有单元测试，就说明原有的外部可见行为未变，符合重构定义
- 写单元测试的过程本身就是代码Code Review和重构的过程，能有效地发现代码中的bug和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是TDD可落地执行的改进方案。

### 代码的可测试性

- mock：如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的mock就是用一个“假”的服务替换真正的服务。mock的服务完全在我们的控制之下，模拟输出我们想要的数据。

- 手动mock的方法：
  - 继承外部依赖类，在依赖注入时替换原外部依赖类
  - 如果是外部依赖类是单例，我们无法mock（无法继承与重写），也无法通过依赖注入的方式来替换，但可以将外部依赖类抽象到一个新的类中（二次封装），然后在依赖注入时使用新类

- Anti-Patterns（典型的、可测试性差的代码）

  - 未决行为：所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码，应该把这部分代码二次封装去测试

  - 全局变量：全局变量是一种面向过程的编程风格，让编写单测更加困难，单元测试框架有可能并发执行，单测结果随机且不可控
  - 静态方法：静态方法也很难mock
  - 复杂继承：父类mock某个依赖对象才能进行单测，那子类、子类的子类...都需要mock
  - 高耦合：需要mock很多个外部对象才能单测

### 解耦

- 如何解耦
  - 封装与抽象
  - 中间层
  - 模块化

### 编程规范的建议

- 命名：

  - 长度：大家熟知的可以用缩写；作用域小的变量可以短点，作用域大的/出现跨度大的用长命名
  - 上下文简化：比如User类的属性直接叫name即可，用起来时user.getName()可以帮阅读者理解
  - 命名要可读的（从嘴巴读出来）、可搜索的（与团队保持一致）

- 注释：

  - 注释比代码承载信息更多
  - 注释起到总结性作用、文档的作用
  - 一些总结性注释能让代码结构更清晰

  - 类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

- 代码风格：
  - 一行代码最长不能超过IDE显示的宽度
  - 善用空行风格单元块
  - 不管是用两格缩进还是四格缩进，一定不要用tab键缩进。因为在不同的IDE下，tab键的显示宽度不同
  - 成员排列顺序：不同语言不同；有调用关系的函数可以放一块

- 其他：
  - 把代码分割成更小的单元块：抽象成函数，函数命名有助于理解
  - 避免函数参数过多：过多时要考虑函数职责是否单一，可以将函数参数封装成对象
  - 谨慎考虑用函数参数来控制逻辑：通过布尔值入参控制函数内部逻辑，明显违背了单一职责原则和接口隔离原则；但如果函数是私有函数，影响范围有限，也可以酌情考虑保留布尔参数
  - 函数设计要职责单一
  - 移除过深的嵌套层次
  - 学会使用解释性变量：常量取代魔法值；解释性变量解释复杂表达式

![image-20220105230238739](https://tva1.sinaimg.cn/large/008i3skNly1gy36zuje50j318k0gu0wm.jpg)![image-20220105230252830](https://tva1.sinaimg.cn/large/008i3skNly1gy3701i9eoj318q0g8diq.jpg)

### 程序出错返回啥？

- 错误码：C语言没有异常，所以错误码是最常用的出错处理方式。错误码的返回方式有两种：一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。
- 返回NULL值：NULL值有诸多弊端，如忘记检查造成NPE问题，判空代码太多影响主代码，但是NULL值也有优点，它表示了不存在的语义
- 返回空对象：空对象设计模式
- 抛出异常对象：
  - 像C++和大部分的动态语言（Python、Ruby、JavaScript等）都只定义了一种异常类型：运行时异常（Runtime Exception）。而像Java，除了运行时异常外，还定义了另外一种异常类型：编译时异常（Compile Exception）。
  - 如果调用方不关心异常，可以try catch异常
  - 如果调用方关心异常，且在业务概念上有相关性，应该re-throw异常
  - 如果抛出的异常太底层，调用方看不懂，可以重新包装成调用方理解的异常抛出

## 设计模式与范式：创建型

### **单例设计模式**（Singleton Design Pattern）

- 一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。
- 唯一性的理解：进程内唯一，多线程下也是唯一的
- 场景：
  - 处理资源访问冲突：比如有个日志类，多线程场景下，多个对象使用会造成相互覆盖，这时可以用单例模式保证所有线程都是用一个Logger对象
  - 表示全局唯一类：从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如配置信息类、唯一ID生成器等等
- 实现单例模式考虑点：
  - 构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；
  - 考虑对象创建时的线程安全问题；
  - 考虑是否支持延迟加载；
  - 考虑getInstance()性能是否高（是否加锁）。

- Java的具体实现：

  - 饿汉式：在类加载的时候，instance静态实例就已经创建并初始化好了，是线程安全的，不支持延迟加载

    ```java
    public class A {
      private static final instance_ = new A();
      private A() {}
      public static A getInstance() {
        return instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 懒汉式：相对于饿汉式的优势是支持延迟加载，但这种方法的缺点很明显，加了一把大锁（synchronzed），如果这个单例类经常被用到，显然会称为性能瓶颈

    ```java
    public class A {
      private static final instance_;
      private A() {}
      public static synchronized A getInstance() {
        if (instance_ == null) {
          instance_ = new A();
        return instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 双重检测：饿汉式不支持延迟加载，懒汉式有性能问题，双重检测则是实现高并发又能延迟加载的方法

    ```java
    public class A {
      private static final instance_;
      private A() {}
      public static A getInstance() {
        if (instance_ == null) {
          synchronized(A.class){
            if (instance_ == null){
              instance_ = new A();
            }
          }
        }
        return instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 静态内部类：类似饿汉式，但又能做到延迟加载，外部类被加载时，并不会创建静态内部类的实例对象只有当调用getInstance方法时，SingleHolder才会创建出实例，instance_的唯一性、创建过程的线程安全性都由JVM来保证

    ```java
    public class A {
      private A() {}
      private static class SingleHolder() {
        private static final A instance_ = new A();
      }
      public static A getInstance() {
        return SingleHolder.instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 枚举：Java类型本身的特性，保证了线程安全与实例唯一

    ```java
    public enum A {
      INSTANCE;
      // 业务方法...
      public bizService() {...}
    }
    ```

- 单例模式的问题
  - 对OOP支持不友好：一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性
  - 对可扩展性支持不友好，比如数据库连接池最好不要设计成单例模式，否则慢SQL会阻塞正常SQL
  - 单例模式对可测试性不友好：单例模式的成员变量是全局共享的，不同单测之间可能会修改这个成员变量，而且非常隐蔽，对于并发执行的单测框架，结果是无法预知的
  - 单例不支持有有参数的构造参数：最优的解决办法是参数从全局变脸或者配置文件中读取

- 单例模式的替代方案
  - 为了保证全局唯一，可以使用静态方法，但不是很灵活，且不支持延迟加载
  - 依赖注入+工厂模式/IOC容器（保证只创建一个对象）

- 如何实现线程唯一的单例类

  - HashMap来存储对象，其中key是线程ID，value是对象

  - Java语言本身提供了ThreadLocal工具类，可以更加轻松地实现线程唯一单例，ThreadLocal底层也是基于HashMap的

    ```java
    public class A {
      private static final ConcurrentHashMap<Long, A> instance_ = new ConcurrentHashMap<>();
      private A() {}
      public static A getInstance() {
        Long currentThreadId = Thread.currentThread().getId();
        instance_putIfAbsent(currentThreadId, new IdGenerator());
        return instances.get(currentThreadId);
      }
    }
    ```

- 如何实现集群唯一的单例类

  - 集群唯一就是在多进程之间只有一个实例对象

  - 具体做法：需要把这个单例对象序列化并存储到外部共享存储区（比如文件）进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证进程唯一，要加锁，使用完对象后还需要将其从内存删除并释放锁

    ```java
    public class A {
      private A() {}
      private static A instance_;
      private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);
      private static DistributedLock lock = new DistributedLock();
      
      public synchronized static A getInstance() 
        if (instance_ == null) {
          lock.lock();
          instance_ = storage.load(A.class);
        }
        return instance_;
      }
      
      public synchroinzed void freeInstance() {
        storage.save(this, A.class);
        instance = null; //释放对象
        lock.unlock();
      }
    
    	// 业务代码
    	public xxx () {}
    }
    
    // IdGenerator使用举例
    A a = A.getInstance();
    a.xxx(); 
    A.freeInstance();
    ```

    

- 多例模式

  - 一个类可以创建有限个对象

    ```java
    public class BackendServer {
      private long serverNo;
      private String serverAddress;
    
      private static final int SERVER_COUNT = 3;
      private static final Map<Long, BackendServer> serverInstances = new HashMap<>();
    
      static {
        serverInstances.put(1L, new BackendServer(1L, "192.134.22.138:8080"));
        serverInstances.put(2L, new BackendServer(2L, "192.134.22.139:8080"));
        serverInstances.put(3L, new BackendServer(3L, "192.134.22.140:8080"));
      }
    
      private BackendServer(long serverNo, String serverAddress) {
        this.serverNo = serverNo;
        this.serverAddress = serverAddress;
      }
    
      public BackendServer getInstance(long serverNo) {
        return serverInstances.get(serverNo);
      }
    
      public BackendServer getRandomInstance() {
        Random r = new Random();
        int no = r.nextInt(SERVER_COUNT)+1;
        return serverInstances.get(no);
      }
    }
    ```

  - 另一种理解：同一类型的只能创建一个对象

    ```java
    public class Logger {
      private static final ConcurrentHashMap<String, Logger> instances
              = new ConcurrentHashMap<>();
    
      private Logger() {}
    
      public static Logger getInstance(String loggerName) {
        instances.putIfAbsent(loggerName, new Logger());
        return instances.get(loggerName);
      }
    
      public void log() {
        //...
      }
    }
    
    //l1==l2, l1!=l3
    Logger l1 = Logger.getInstance("User.class");
    Logger l2 = Logger.getInstance("User.class");
    Logger l3 = Logger.getInstance("Order.class");
    ```

    

