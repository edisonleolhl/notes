# 设计模式之美



## 面向对象

### 概述

- 面向对象的四大特性：封装、抽象、继承、多态
- **按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言**

- 面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程

### 四大特性解决什么问题

- 封装（Encapsulation）：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据
- 抽象（Abstraction）： 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
  - 不一定非要编写接口类才叫抽象，单纯的类本身就是满足抽象特性的，通过函数对外提供函数签名，调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。
- 继承（Inheritance）：继承是用来表示类之间的is-a关系，为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用<。不过，有些编程语言只支持单继承，不支持多重继承，比如Java、PHP、C#、Ruby等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl等
  - 继承最大的一个好处就是代码复用

- 多态（Polymorphism）：多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

  - 三种实现方法：

    - 继承加方法重写：编程语言要支持父类对象可以引用子类对象&&编程语言要支持继承&&编程语言要支持子类可以重写（override）父类中的方法

    - 接口类：class xxx implement interface，C++不支持接口类，Java支持接口类

    - duck-typing：只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，只有一些动态语言如Python、JavaScript才支持

      ```python
      class Logger:
          def record(self):
              print(“I write a log into file.”)
              
      class DB:
          def record(self):
              print(“I insert data into db. ”)
              
      def test(recorder):
          recorder.record()
      
      def demo():
          logger = Logger()
          db = DB()
          test(logger)
          test(db)
      ```

  - 多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等

### 面向对象vs面向过程

- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。
- 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。
- 面向对象比面向过程有哪些优势？
  - OOP更加能够应对大规模复杂程序的开发
  - OOP风格的代码更易复用、易扩展、易维护
  - OOP语言更加人性化、更加高级、更加智能

### 哪些代码看似面向对象实则面向过程

- 滥用getter、setter方法
- 滥用全局变量和全局方法
  - Constants类可拆分为更细化的多个类，如MySqlConstants类、RedisConstants类
  - Utils类也可拆分，只包含静态方法不包含任何属性的Utils类，是彻彻底底的面向过程的编程风格，但我们不排斥这种面向过程的编程风格

- 定义数据和方法分离的类
  - 如MVC贫血模型
- 我们之所以容易写出面向过程风格的代码，是因为与我们的大脑顺序思考的结果有关。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。

### 接口vs抽象类

- 并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++这种编程语言只支持抽象类，不支持接口；而像Python这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。
- 抽象类特点（以Java为例）
  - 抽象类不允许被实例化，只能被继承。也就是说，你不能new一个抽象类的对象出来
  - 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。
  - 子类继承抽象类，必须实现抽象类中的所有抽象方法

- 接口特点（以Java为例）
  - 接口不能包含属性（也就是成员变量）。
  - 接口只能声明方法，方法不能包含代码实现。
  - 类实现接口的时候，必须实现接口中声明的所有方法。

- 理解：抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种is-a的关系，那抽象类既然属于类，也表示一种is-a的关系。相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

- 抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。
- 实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。

- C++没有接口，但可以通过抽象类来模拟接口，

  ```c++
  // 抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。
  class Strategy { // 用抽象类模拟接口
    public:
      ~Strategy();
      virtual void algorithm()=0;
    protected:
      Strategy();
  };
  ```

- Java可以用普通类模拟接口，

  ```java
  // 普通类的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出MethodUnSupportedException异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。
  public class MockInteface {
    protected MockInteface() {}
    public void funcA() {
      throw new MethodUnSupportedException();
    }
  }
  ```

- 如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示_x0008_一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。

### 基于接口而非实现编程

- Program to an interface, not an implementation
- 这里的接口不是指interface语法的接口，事实上，这条原则最早出现于1994年GoF的《设计模式》，比很多编程语言如Java都还要诞生得早

- 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。

- **越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。**而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。
- 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

### 多用组合少用继承

- 虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。
- 比如，大部分的鸟都会飞，但如果在抽象鸟类中定义fly()方法，所有鸟（如燕子、鸽子、鸵鸟）都要重写fly()方法，但是鸵鸟不会飞，这就需要将抽象鸟类细化成抽象的会飞鸟类与抽象的不会飞鸟类，如果此时还有『是否会叫』，『是否会下蛋』，继承层次就会越来越深了

- 可以使用组合（composition）、接口、委托（delegation）解决继承的问题

  ```java
  public interface Flyable {
    void fly()；
  }
  public class FlyAbility implements Flyable {
    @Override
    public void fly() { //... }
  }
  //省略Tweetable/TweetAbility/EggLayable/EggLayAbility
  
  public class Ostrich implements Tweetable, EggLayable {//鸵鸟
    private TweetAbility tweetAbility = new TweetAbility(); //组合
    private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
    //... 省略其他属性和方法...
    @Override
    public void tweet() {
      tweetAbility.tweet(); // 委托
    }
    @Override
    public void layEgg() {
      eggLayAbility.layEgg(); // 委托
    }
  }
  ```

- 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

- 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

### 贫血模型的MVC架构违背OOP吗

- 在贫血模型中，数据和业务逻辑被分割到不同的类中。**充血模型**（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
- MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑
- 在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。

- 为什么贫血模型的传统开发模式受欢迎？
  - 业务简单，贫血模型应付足矣
  - 充血模型设计更有难度
  - 思维固化，转型有成本

- 平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。
- 基于充血模型的DDD的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

- 复杂的系统对代码复用性、可扩展性、可维护性要求更高，应该花更多精力在前期设计上，DDD正好需要前期大量调研

### 充血模型

- **在基于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类变得很薄，但并没有完全删除Service类，这是因为：**
  - Service类负责与Repository交流，领域模型不应与其他层代码（如Repo层）耦合在一起
  - Service类负责跨领域模型的业务聚合功能
  - Service类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC接口等，都可以放到Service类中。

- Service层充血了，Controller层与Repository层是否也需要充血？
  - 没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多

### 面向对象设计和编程——方法论

1. **划分职责进而识别出有哪些类**

   根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

2. **定义类及其属性和方法**

   我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

3. **定义类与类之间的交互关系**

   UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

4. **将类组装起来并提供执行入口**

   我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。

## 设计原则

### 单一职责

- A class or module should have a single responsibility
- 不要设计大而全的类，要设计粒度小、功能单一的类

- 举例，社交产品中UserInfo类是否满足单一职责原则呢？

  ```java
  public class UserInfo {
    private long userId;
    private String username;
    private String email;
    private String telephone;
    private long createTime;
    private long lastLoginTime;
    private String avatarUrl;
    private String provinceOfAddress; // 省
    private String cityOfAddress; // 市
    private String regionOfAddress; // 区 
    private String detailedAddress; // 详细地址
    // ...省略其他属性和方法...
  }
  ```

  - 一种观点是，UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；
  - 另一种观点是，地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的UserAddress类，UserInfo只保留除Address之外的其他信息，拆分之后的两个类的职责更加单一
  - 进一步延伸，如果社交平台发展成电商平台，就需要物流信息，地址最好拆分出来
  - 再延伸，公司开发了其他产品，希望支持统一账号系统，身份认证相关的信息如email、telephone等也可以抽取出来成独立的类

- 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的

- 最佳实践：
  - **先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，可以考虑拆分**
  - 类中的代码行数、函数或属性过多时
  - 类依赖的其他类过多，或者依赖类的其他类过多时
  - 私有方法过多时
  - 比较难给类起一个合适名字，很难用一个业务名词概括时
  - 类中大量的方法都是集中操作类中的某几个属性时

### 开闭原则

- Open Closed Principle：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification
- 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

- 添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则

- 最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，可以做事先做扩展性设计

### 里式替换原则

- If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
- Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
- 理解：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

- 多态和里式替换有点类似，但它们关注的角度是不一样的
  - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。
  - 里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

- 里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。

- 违反里式替换原则的例子：
  - 违反父类声明的功能：父类提供sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个函数之后，是按照创建日期来给订单排序的
  - 违反父类对输入/输出/异常的约定：父类某个函数运行出错的时候返回null，子类重写运行出错返回异常
  - 违反父类注释中所罗列的任何特殊说明：父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额

- 简单验证：拿父类的单元测试去验证子类的代码，如果有失败，则有可能违背里式替换原则

### 接口隔离原则

- Interface Segregation Principle”，缩写为ISP，Clients should not be forced to depend upon interfaces that they do not use
- 把“接口”理解为一组API接口集合，比如用户服务这组API接口是对外提供的，鉴权用户这组API接口是对内（后台管理人员）提供的，这就符合接口隔离原则
- 把“接口”理解为单个API接口或函数，函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
- 把“接口”理解为OOP中的接口概念，接口粒度要小
- 与单一职责原则的区别：单一职责原则针对的是模块、类、接口的设计，接口隔离原则更侧重于接口的设计

### 依赖反转

- 控制反转的英文翻译是Inversion Of Control，缩写为IOC，是一种设计思想，这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
  - 实现控制反转的方式有很多，除了依赖注入，还有模板模式等

- 依赖注入的英文翻译是Dependency Injection，缩写为DI，是一种具体的编程技巧，具体指：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。**提高了代码的扩展性**
- 依赖注入框架，比如Google Guice、Java Spring、Pico Container、Butterfly Container等，Spring框架是**控制反转容器**（Inversion Of Control Container）

- 依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP，High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

### KISS&YAGNI

- keep it simple and stupid，尽可能简单
- 并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等
- 比如解决文本字符串匹配问题，KMP算法虽然非常复杂，但文本字符串匹配问题本身就很复杂，所以KMP算法仍然是满足KISS原则的，

- YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它，不要过度设计
  - 比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。
- KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）

### DRY与复用性

- Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。

- 举例：
  - 实现逻辑重复：有两个一模一样的校验用户账号与密码的函数，其实并不违反DRY，因为账号与密码以后可能会有不同的逻辑，但重复的代码片段可以抽出公共函数
  - 功能语义重复：有isValidIp()和checkIfIpValid()两个函数，都是用来校验IP是否合法的，所以违反了DRY
  - 代码执行重复：比如多次鉴权判断，如果是IO，非常耗时

### 迪米特法则与高内聚、低耦合

- “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。
- 高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。**单一职责原则是实现高内聚的有效手段之一**

- 松耦合，类与类之间的依赖关系简单清晰，依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了松耦合

- Law of Demeter，缩写是LOD，The Least Knowledge Principle，Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.

- **如何理解“迪米特法则”？**

  不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。