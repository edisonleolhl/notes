# 设计模式之美



## 面向对象

### 概述

- 面向对象的四大特性：封装、抽象、继承、多态
- **按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言**

- 面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程

### 四大特性解决什么问题

- 封装（Encapsulation）：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据
- 抽象（Abstraction）： 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
  - 不一定非要编写接口类才叫抽象，单纯的类本身就是满足抽象特性的，通过函数对外提供函数签名，调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。
- 继承（Inheritance）：继承是用来表示类之间的is-a关系，为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用<。不过，有些编程语言只支持单继承，不支持多重继承，比如Java、PHP、C#、Ruby等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl等
  - 继承最大的一个好处就是代码复用

- 多态（Polymorphism）：多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

  - 三种实现方法：

    - 继承加方法重写：编程语言要支持父类对象可以引用子类对象&&编程语言要支持继承&&编程语言要支持子类可以重写（override）父类中的方法

    - 接口类：class xxx implement interface，C++不支持接口类，Java支持接口类

    - duck-typing：只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，只有一些动态语言如Python、JavaScript才支持

      ```python
      class Logger:
          def record(self):
              print(“I write a log into file.”)
              
      class DB:
          def record(self):
              print(“I insert data into db. ”)
              
      def test(recorder):
          recorder.record()
      
      def demo():
          logger = Logger()
          db = DB()
          test(logger)
          test(db)
      ```

  - 多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等

### 面向对象vs面向过程

- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。
- 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。
- 面向对象比面向过程有哪些优势？
  - OOP更加能够应对大规模复杂程序的开发
  - OOP风格的代码更易复用、易扩展、易维护
  - OOP语言更加人性化、更加高级、更加智能

### 哪些代码看似面向对象实则面向过程

- 滥用getter、setter方法
- 滥用全局变量和全局方法
  - Constants类可拆分为更细化的多个类，如MySqlConstants类、RedisConstants类
  - Utils类也可拆分，只包含静态方法不包含任何属性的Utils类，是彻彻底底的面向过程的编程风格，但我们不排斥这种面向过程的编程风格

- 定义数据和方法分离的类
  - 如MVC贫血模型
- 我们之所以容易写出面向过程风格的代码，是因为与我们的大脑顺序思考的结果有关。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。

### 接口vs抽象类

- 并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++这种编程语言只支持抽象类，不支持接口；而像Python这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。
- 抽象类特点（以Java为例）
  - 抽象类不允许被实例化，只能被继承。也就是说，你不能new一个抽象类的对象出来
  - 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。
  - 子类继承抽象类，必须实现抽象类中的所有抽象方法

- 接口特点（以Java为例）
  - 接口不能包含属性（也就是成员变量）。
  - 接口只能声明方法，方法不能包含代码实现。
  - 类实现接口的时候，必须实现接口中声明的所有方法。

- 理解：抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种is-a的关系，那抽象类既然属于类，也表示一种is-a的关系。相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

- 抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。
- 实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。

- C++没有接口，但可以通过抽象类来模拟接口，

  ```c++
  // 抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。
  class Strategy { // 用抽象类模拟接口
    public:
      ~Strategy();
      virtual void algorithm()=0;
    protected:
      Strategy();
  };
  ```

- Java可以用普通类模拟接口，

  ```java
  // 普通类的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出MethodUnSupportedException异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。
  public class MockInteface {
    protected MockInteface() {}
    public void funcA() {
      throw new MethodUnSupportedException();
    }
  }
  ```

- 如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示_x0008_一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。

### 基于接口而非实现编程

- Program to an interface, not an implementation
- 这里的接口不是指interface语法的接口，事实上，这条原则最早出现于1994年GoF的《设计模式》，比很多编程语言如Java都还要诞生得早

- 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。

- **越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。**而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。
- 从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

### 多用组合少用继承

- 虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。
- 比如，大部分的鸟都会飞，但如果在抽象鸟类中定义fly()方法，所有鸟（如燕子、鸽子、鸵鸟）都要重写fly()方法，但是鸵鸟不会飞，这就需要将抽象鸟类细化成抽象的会飞鸟类与抽象的不会飞鸟类，如果此时还有『是否会叫』，『是否会下蛋』，继承层次就会越来越深了

- 可以使用组合（composition）、接口、委托（delegation）解决继承的问题

  ```java
  public interface Flyable {
    void fly()；
  }
  public class FlyAbility implements Flyable {
    @Override
    public void fly() { //... }
  }
  //省略Tweetable/TweetAbility/EggLayable/EggLayAbility
  
  public class Ostrich implements Tweetable, EggLayable {//鸵鸟
    private TweetAbility tweetAbility = new TweetAbility(); //组合
    private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
    //... 省略其他属性和方法...
    @Override
    public void tweet() {
      tweetAbility.tweet(); // 委托
    }
    @Override
    public void layEgg() {
      eggLayAbility.layEgg(); // 委托
    }
  }
  ```

- 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

- 除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

### 贫血模型的MVC架构违背OOP吗

- 在贫血模型中，数据和业务逻辑被分割到不同的类中。**充血模型**（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
- MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑
- 在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。

- 为什么贫血模型的传统开发模式受欢迎？
  - 业务简单，贫血模型应付足矣
  - 充血模型设计更有难度
  - 思维固化，转型有成本

- 平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。
- 基于充血模型的DDD的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

- 复杂的系统对代码复用性、可扩展性、可维护性要求更高，应该花更多精力在前期设计上，DDD正好需要前期大量调研

### 充血模型

- **在基于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类变得很薄，但并没有完全删除Service类，这是因为：**
  - Service类负责与Repository交流，领域模型不应与其他层代码（如Repo层）耦合在一起
  - Service类负责跨领域模型的业务聚合功能
  - Service类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC接口等，都可以放到Service类中。

- Service层充血了，Controller层与Repository层是否也需要充血？
  - 没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多

### 面向对象设计和编程——方法论

1. **划分职责进而识别出有哪些类**

   根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

2. **定义类及其属性和方法**

   我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

3. **定义类与类之间的交互关系**

   UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

4. **将类组装起来并提供执行入口**

   我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。

## 设计原则

### 单一职责

- A class or module should have a single responsibility
- 不要设计大而全的类，要设计粒度小、功能单一的类

- 举例，社交产品中UserInfo类是否满足单一职责原则呢？

  ```java
  public class UserInfo {
    private long userId;
    private String username;
    private String email;
    private String telephone;
    private long createTime;
    private long lastLoginTime;
    private String avatarUrl;
    private String provinceOfAddress; // 省
    private String cityOfAddress; // 市
    private String regionOfAddress; // 区 
    private String detailedAddress; // 详细地址
    // ...省略其他属性和方法...
  }
  ```

  - 一种观点是，UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；
  - 另一种观点是，地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的UserAddress类，UserInfo只保留除Address之外的其他信息，拆分之后的两个类的职责更加单一
  - 进一步延伸，如果社交平台发展成电商平台，就需要物流信息，地址最好拆分出来
  - 再延伸，公司开发了其他产品，希望支持统一账号系统，身份认证相关的信息如email、telephone等也可以抽取出来成独立的类

- 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的

- 最佳实践：
  - **先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，可以考虑拆分**
  - 类中的代码行数、函数或属性过多时
  - 类依赖的其他类过多，或者依赖类的其他类过多时
  - 私有方法过多时
  - 比较难给类起一个合适名字，很难用一个业务名词概括时
  - 类中大量的方法都是集中操作类中的某几个属性时

### 开闭原则

- Open Closed Principle：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification
- 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

- 添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则

- 最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，可以做事先做扩展性设计

### 里式替换原则

- If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
- Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
- 理解：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

- 多态和里式替换有点类似，但它们关注的角度是不一样的
  - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。
  - 里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

- 里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。

- 违反里式替换原则的例子：
  - 违反父类声明的功能：父类提供sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个函数之后，是按照创建日期来给订单排序的
  - 违反父类对输入/输出/异常的约定：父类某个函数运行出错的时候返回null，子类重写运行出错返回异常
  - 违反父类注释中所罗列的任何特殊说明：父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额

- 简单验证：拿父类的单元测试去验证子类的代码，如果有失败，则有可能违背里式替换原则

### 接口隔离原则

- Interface Segregation Principle”，缩写为ISP，Clients should not be forced to depend upon interfaces that they do not use
- 把“接口”理解为一组API接口集合，比如用户服务这组API接口是对外提供的，鉴权用户这组API接口是对内（后台管理人员）提供的，这就符合接口隔离原则
- 把“接口”理解为单个API接口或函数，函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
- 把“接口”理解为OOP中的接口概念，接口粒度要小
- 与单一职责原则的区别：单一职责原则针对的是模块、类、接口的设计，接口隔离原则更侧重于接口的设计

### 依赖反转

- 控制反转的英文翻译是Inversion Of Control，缩写为IOC，是一种设计思想，这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
  - 实现控制反转的方式有很多，除了依赖注入，还有模板模式等

- 依赖注入的英文翻译是Dependency Injection，缩写为DI，是一种具体的编程技巧，具体指：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。**提高了代码的扩展性**
- 依赖注入框架，比如Google Guice、Java Spring、Pico Container、Butterfly Container等，Spring框架是**控制反转容器**（Inversion Of Control Container）

- 依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP，High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

### KISS&YAGNI

- keep it simple and stupid，尽可能简单
- 并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等
- 比如解决文本字符串匹配问题，KMP算法虽然非常复杂，但文本字符串匹配问题本身就很复杂，所以KMP算法仍然是满足KISS原则的，

- YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它，不要过度设计
  - 比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。
- KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）

### DRY与复用性

- Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。

- 举例：
  - 实现逻辑重复：有两个一模一样的校验用户账号与密码的函数，其实并不违反DRY，因为账号与密码以后可能会有不同的逻辑，但重复的代码片段可以抽出公共函数
  - 功能语义重复：有isValidIp()和checkIfIpValid()两个函数，都是用来校验IP是否合法的，所以违反了DRY
  - 代码执行重复：比如多次鉴权判断，如果是IO，非常耗时

### 迪米特法则与高内聚、低耦合

- “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。
- 高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。**单一职责原则是实现高内聚的有效手段之一**

- 松耦合，类与类之间的依赖关系简单清晰，依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了松耦合

- Law of Demeter，缩写是LOD，The Least Knowledge Principle，Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.

- **如何理解“迪米特法则”？**

  不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

### 实战

#### 为什么要MVC分层

1. 分层能起到代码复用的作用
2. 分层能起到隔离变化的作用
3. 分层能起到隔离关注点的作用
4. 分层能提高代码的可测试性
5. 分层能应对系统的复杂性

#### BO、VO、Entity的意义

- 针对Controller、Service、Repository三层，每层都会定义相应的数据对象，它们分别是VO（View Object）、BO（Business Object）、Entity

- VO、BO、Entity三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背DRY原则。在前面讲到DRY原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。
- 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！

### 如何开发复杂系统

- 对业务系统，可以从已有项目架构中借鉴，然后从一个用户用例出发，思考如何搭建
- 对于非业务系统，可以搭建最小原型，快速地run起来，这是迭代的基础

## 规范与重构

### 重构概述

- 软件设计大师Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”

- “初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”

- 持续重构：作为开发的一部分，代码质量总会存在不完美，重构就会持续进行

### 如何保证重构不出错

- 最有效的手段就是单元测试，如果新的代码仍然能通过所有单元测试，就说明原有的外部可见行为未变，符合重构定义
- 写单元测试的过程本身就是代码Code Review和重构的过程，能有效地发现代码中的bug和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是TDD可落地执行的改进方案。

### 代码的可测试性

- mock：如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的mock就是用一个“假”的服务替换真正的服务。mock的服务完全在我们的控制之下，模拟输出我们想要的数据。

- 手动mock的方法：
  - 继承外部依赖类，在依赖注入时替换原外部依赖类
  - 如果是外部依赖类是单例，我们无法mock（无法继承与重写），也无法通过依赖注入的方式来替换，但可以将外部依赖类抽象到一个新的类中（二次封装），然后在依赖注入时使用新类

- Anti-Patterns（典型的、可测试性差的代码）

  - 未决行为：所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码，应该把这部分代码二次封装去测试

  - 全局变量：全局变量是一种面向过程的编程风格，让编写单测更加困难，单元测试框架有可能并发执行，单测结果随机且不可控
  - 静态方法：静态方法也很难mock
  - 复杂继承：父类mock某个依赖对象才能进行单测，那子类、子类的子类...都需要mock
  - 高耦合：需要mock很多个外部对象才能单测

### 解耦

- 如何解耦
  - 封装与抽象
  - 中间层
  - 模块化

### 编程规范的建议

- 命名：

  - 长度：大家熟知的可以用缩写；作用域小的变量可以短点，作用域大的/出现跨度大的用长命名
  - 上下文简化：比如User类的属性直接叫name即可，用起来时user.getName()可以帮阅读者理解
  - 命名要可读的（从嘴巴读出来）、可搜索的（与团队保持一致）

- 注释：

  - 注释比代码承载信息更多
  - 注释起到总结性作用、文档的作用
  - 一些总结性注释能让代码结构更清晰

  - 类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

- 代码风格：
  - 一行代码最长不能超过IDE显示的宽度
  - 善用空行风格单元块
  - 不管是用两格缩进还是四格缩进，一定不要用tab键缩进。因为在不同的IDE下，tab键的显示宽度不同
  - 成员排列顺序：不同语言不同；有调用关系的函数可以放一块

- 其他：
  - 把代码分割成更小的单元块：抽象成函数，函数命名有助于理解
  - 避免函数参数过多：过多时要考虑函数职责是否单一，可以将函数参数封装成对象
  - 谨慎考虑用函数参数来控制逻辑：通过布尔值入参控制函数内部逻辑，明显违背了单一职责原则和接口隔离原则；但如果函数是私有函数，影响范围有限，也可以酌情考虑保留布尔参数
  - 函数设计要职责单一
  - 移除过深的嵌套层次
  - 学会使用解释性变量：常量取代魔法值；解释性变量解释复杂表达式

![image-20220105230238739](https://tva1.sinaimg.cn/large/008i3skNly1gy36zuje50j318k0gu0wm.jpg)![image-20220105230252830](https://tva1.sinaimg.cn/large/008i3skNly1gy3701i9eoj318q0g8diq.jpg)

### 程序出错返回啥？

- 错误码：C语言没有异常，所以错误码是最常用的出错处理方式。错误码的返回方式有两种：一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。
- 返回NULL值：NULL值有诸多弊端，如忘记检查造成NPE问题，判空代码太多影响主代码，但是NULL值也有优点，它表示了不存在的语义
- 返回空对象：空对象设计模式
- 抛出异常对象：
  - 像C++和大部分的动态语言（Python、Ruby、JavaScript等）都只定义了一种异常类型：运行时异常（Runtime Exception）。而像Java，除了运行时异常外，还定义了另外一种异常类型：编译时异常（Compile Exception）。
  - 如果调用方不关心异常，可以try catch异常
  - 如果调用方关心异常，且在业务概念上有相关性，应该re-throw异常
  - 如果抛出的异常太底层，调用方看不懂，可以重新包装成调用方理解的异常抛出

## 设计模式与范式：创建型

- 单例模式用来创建全局唯一的对象。
- 工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。
- 建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。
- 原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

### **单例设计模式**（Singleton）

- 一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。
- 唯一性的理解：进程内唯一，多线程下也是唯一的
- 场景：
  - 处理资源访问冲突：比如有个日志类，多线程场景下，多个对象使用会造成相互覆盖，这时可以用单例模式保证所有线程都是用一个Logger对象
  - 表示全局唯一类：从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如配置信息类、唯一ID生成器等等
- 实现单例模式考虑点：
  - 构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；
  - 考虑对象创建时的线程安全问题；
  - 考虑是否支持延迟加载；
  - 考虑getInstance()性能是否高（是否加锁）。

- Java的具体实现：

  - 饿汉式：在类加载的时候，instance静态实例就已经创建并初始化好了，是线程安全的，不支持延迟加载

    ```java
    public class A {
      private static final instance_ = new A();
      private A() {}
      public static A getInstance() {
        return instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 懒汉式：相对于饿汉式的优势是支持延迟加载，但这种方法的缺点很明显，加了一把大锁（synchronzed），如果这个单例类经常被用到，显然会称为性能瓶颈

    ```java
    public class A {
      private static final instance_;
      private A() {}
      public static synchronized A getInstance() {
        if (instance_ == null) {
          instance_ = new A();
        return instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 双重检测：饿汉式不支持延迟加载，懒汉式有性能问题，双重检测则是实现高并发又能延迟加载的方法

    ```java
    public class A {
      private static final instance_;
      private A() {}
      public static A getInstance() {
        if (instance_ == null) {
          synchronized(A.class){
            if (instance_ == null){
              instance_ = new A();
            }
          }
        }
        return instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 静态内部类：类似饿汉式，但又能做到延迟加载，外部类被加载时，并不会创建静态内部类的实例对象只有当调用getInstance方法时，SingleHolder才会创建出实例，instance_的唯一性、创建过程的线程安全性都由JVM来保证

    ```java
    public class A {
      private A() {}
      private static class SingleHolder() {
        private static final A instance_ = new A();
      }
      public static A getInstance() {
        return SingleHolder.instance_;
      }
      
      // 业务方法...
      public bizService() {...}
    ```

  - 枚举：Java类型本身的特性，保证了线程安全与实例唯一

    ```java
    public enum A {
      INSTANCE;
      // 业务方法...
      public bizService() {...}
    }
    ```

- 单例模式的问题
  - 对OOP支持不友好：一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性
  - 对可扩展性支持不友好，比如数据库连接池最好不要设计成单例模式，否则慢SQL会阻塞正常SQL
  - 单例模式对可测试性不友好：单例模式的成员变量是全局共享的，不同单测之间可能会修改这个成员变量，而且非常隐蔽，对于并发执行的单测框架，结果是无法预知的
  - 单例不支持有有参数的构造参数：最优的解决办法是参数从全局变脸或者配置文件中读取

- 单例模式的替代方案
  - 为了保证全局唯一，可以使用静态方法，但不是很灵活，且不支持延迟加载
  - 依赖注入+工厂模式/IOC容器（保证只创建一个对象）

- 如何实现线程唯一的单例类

  - HashMap来存储对象，其中key是线程ID，value是对象

  - Java语言本身提供了ThreadLocal工具类，可以更加轻松地实现线程唯一单例，ThreadLocal底层也是基于HashMap的

    ```java
    public class A {
      private static final ConcurrentHashMap<Long, A> instance_ = new ConcurrentHashMap<>();
      private A() {}
      public static A getInstance() {
        Long currentThreadId = Thread.currentThread().getId();
        instance_putIfAbsent(currentThreadId, new IdGenerator());
        return instances.get(currentThreadId);
      }
    }
    ```

- 如何实现集群唯一的单例类

  - 集群唯一就是在多进程之间只有一个实例对象

  - 具体做法：需要把这个单例对象序列化并存储到外部共享存储区（比如文件）进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证进程唯一，要加锁，使用完对象后还需要将其从内存删除并释放锁

    ```java
    public class A {
      private A() {}
      private static A instance_;
      private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/);
      private static DistributedLock lock = new DistributedLock();
      
      public synchronized static A getInstance() 
        if (instance_ == null) {
          lock.lock();
          instance_ = storage.load(A.class);
        }
        return instance_;
      }
      
      public synchroinzed void freeInstance() {
        storage.save(this, A.class);
        instance = null; //释放对象
        lock.unlock();
      }
    
    	// 业务代码
    	public xxx () {}
    }
    
    // IdGenerator使用举例
    A a = A.getInstance();
    a.xxx(); 
    A.freeInstance();
    ```

    

- 多例模式

  - 一个类可以创建有限个对象

    ```java
    public class BackendServer {
      private long serverNo;
      private String serverAddress;
    
      private static final int SERVER_COUNT = 3;
      private static final Map<Long, BackendServer> serverInstances = new HashMap<>();
    
      static {
        serverInstances.put(1L, new BackendServer(1L, "192.134.22.138:8080"));
        serverInstances.put(2L, new BackendServer(2L, "192.134.22.139:8080"));
        serverInstances.put(3L, new BackendServer(3L, "192.134.22.140:8080"));
      }
    
      private BackendServer(long serverNo, String serverAddress) {
        this.serverNo = serverNo;
        this.serverAddress = serverAddress;
      }
    
      public BackendServer getInstance(long serverNo) {
        return serverInstances.get(serverNo);
      }
    
      public BackendServer getRandomInstance() {
        Random r = new Random();
        int no = r.nextInt(SERVER_COUNT)+1;
        return serverInstances.get(no);
      }
    }
    ```

  - 另一种理解：同一类型的只能创建一个对象

    ```java
    public class Logger {
      private static final ConcurrentHashMap<String, Logger> instances
              = new ConcurrentHashMap<>();
    
      private Logger() {}
    
      public static Logger getInstance(String loggerName) {
        instances.putIfAbsent(loggerName, new Logger());
        return instances.get(loggerName);
      }
    
      public void log() {
        //...
      }
    }
    
    //l1==l2, l1!=l3
    Logger l1 = Logger.getInstance("User.class");
    Logger l2 = Logger.getInstance("User.class");
    Logger l3 = Logger.getInstance("Order.class");
    ```

    

### 工厂模式（Factory）

- 大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，工厂类中创建对象的方法一般都是create开头

- 简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。简单工厂模式又叫静态工厂方法模式（Static Factory Method Pattern），因为创建对象的方法是静态的

- 工厂方法模式：每个工厂类都只负责创建一种类型的对象，比简单工厂模式要易于扩展，但可能会增加多个类

- 什么时候使用工厂方法模式：当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式

- **我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象**

- 抽象工厂模式：用的比较少，可以让工厂负责创建多个不同类型的对象

- 依赖注入框架，或者叫依赖注入容器（Dependency Injection Container）
  - DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。
  
  - 配置解析：工厂类要创建的类是写死在代码内的，而DI容器应该解耦，一般可以用XML配置文件
  
  - 对象创建：将所有对象的创建放进一个工厂类即可，代码量并不会跟随创建对象的数量而线性膨胀，可以通过**反射机制**，在程序运行的过程中动态加载、创建对象
  
  - 对象的生命周期管理：比如Spring框架中可以通过scope属性，来区分普通对象与单例对象。scope=prototype表示返回新创建的对象，scope=singleton表示返回单例对象。还可以自己决定懒加载机制
  
    > Spring的循环依赖问题：https://www.cnblogs.com/daimzh/p/13256413.html

### **建造者模式（Builder）**

- 创建一个对象最常用的方式是，使用new关键字调用类的构造函数来完成，但是如果参数很多，使用方的代码可读性就很差

- 如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决，但是还是无法解决大量必要参数的问题，也无法解决参数之间的依赖关系

  ```java
  Rectangle r = new Rectange(); // r is invalid
  r.setWidth(2); // r is invalid
  r.setHeight(3); // r is valid
  ```

  

- 建造者模式：我们可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。

- 建造者类可以作为内部类也可以作为外部类

  ```java
  // 内部建造者类示例
  public class ResourcePoolConfig {
    private String name;
    private int maxTotal;
    private int maxIdle;
    private int minIdle;
  
    private ResourcePoolConfig(Builder builder) {
      this.name = builder.name;
      this.maxTotal = builder.maxTotal;
      this.maxIdle = builder.maxIdle;
      this.minIdle = builder.minIdle;
    }
    //...省略getter方法...
  
    //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
    public static class Builder {
      private static final int DEFAULT_MAX_TOTAL = 8;
      private static final int DEFAULT_MAX_IDLE = 8;
      private static final int DEFAULT_MIN_IDLE = 0;
  
      private String name;
      private int maxTotal = DEFAULT_MAX_TOTAL;
      private int maxIdle = DEFAULT_MAX_IDLE;
      private int minIdle = DEFAULT_MIN_IDLE;
  
      public ResourcePoolConfig build() {
        // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
        if (StringUtils.isBlank(name)) {
          throw new IllegalArgumentException("...");
        }
        return new ResourcePoolConfig(this);
      }
  
      public Builder setName(String name) {
        if (StringUtils.isBlank(name)) {
          throw new IllegalArgumentException("...");
        }
        this.name = name;
        return this;
      }
  
      public Builder setMaxTotal(int maxTotal) {...    }
  
      public Builder setMaxIdle(int maxIdle) {...    }
  
      public Builder setMinIdle(int minIdle) {...    }
    }
  }
  // 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
  ResourcePoolConfig config = new ResourcePoolConfig.Builder()
          .setName("dbconnectionpool")
          .setMaxTotal(16)
          .setMaxIdle(10)
          .setMinIdle(12)
          .build();
  ```

- 与工厂模式的区别：
  - 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。
  - 建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象

### 原型模式（Prototype）

- 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作**原型设计模式**（Prototype Design Pattern），简称**原型模式**。
- Java、C++很少用到，JavaScript是一种基于原型的面向对象编程语言
- 如何定义对象的『创建成本』：赋值没啥成本，但如果对象的数据需要从复杂计算、网络/数据库/文件IO读取的，那就成本很大

- 深拷贝和浅拷贝
  - Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。
  - 深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。
  - 如果拷贝的对象是不可变的，可以用浅拷贝，如果是可变对象就要谨慎考虑

## 设计模式与范式：结构型

- 结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题

### 代理模式（Proxy）

- 它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类**附加功能**。
- 有两种实现方式：
  - 代理类与被代理类实现同一接口，然后在代理类中通过委托的方式调用被代理类的原业务逻辑，在委托前后添加附加功能
  - 代理类继承被代理类，在代理类的重写方法中调用父类方法，来执行被代理类的原业务逻辑，在调用父类方法前后添加附加功能

- 动态代理：不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类
- 动态代理的实现：Java的反射
- 动态代理的应用：Spring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。

- 代理模式的应用场景
  - 业务系统的非功能性需求开发，比如：监控、统计、鉴权、限流、事务、幂等、日志
  - **实际上，RPC框架也可以看作一种代理模式**
  - 缓存，AOP切面拦截请求，根据URL选择走带缓存的接口

### 桥接模式（Bridge）

- 实现简单，但理解困难，应用场景有限
- GOF的《设计模式》中的定义：Decouple an abstraction from its implementation so that the two can vary independently（将抽象和实现解耦，让它们可以独立变化）
- 更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”（组合优先于继承）

- 最明显的例子：JDBC，JDBC相当于抽象，具体的Driver就相当于实现，两者可以独立开发，通过对象之间的组合关系组装在一起，JDBC的所有操作都委托给Driver执行

### 装饰器模式（Decorate）

- 主要解决继承关系过于复杂的问题，通过组合来替代继承
- **装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类**
- **装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点**

- Java IO的例子

  ```java
  InputStream in = new FileInputStream("/user/wangzheng/test.txt");
  InputStream bin = new BufferedInputStream(in); // 支持缓存读取
  DataInputStream din = new DataInputStream(bin); // 支持按照基本数据类型来读取数据
  int data = din.readInt();
  ```

- 装饰器模式与代理模式的区别

  - 代理类附加的是跟原始类无关的功能

  - 装饰器类附加的是跟原始类相关的**增强功能**

    ```java
    // 代理模式的代码结构(下面的接口也可以替换成抽象类)
    public interface IA {
      void f();
    }
    public class A impelements IA {
      public void f() { //... }
    }
    public class AProxy implements IA {
      private IA a;
      public AProxy(IA a) {
        this.a = a;
      }
      
      public void f() {
        // 新添加的代理逻辑
        a.f();
        // 新添加的代理逻辑
      }
    }
    
    // 装饰器模式的代码结构(下面的接口也可以替换成抽象类)
    public interface IA {
      void f();
    }
    public class A implements IA {
      public void f() { //... }
    }
    public class ADecorator implements IA {
      private IA a;
      public ADecorator(IA a) {
        this.a = a;
      }
      
      public void f() {
        // 功能增强代码
        a.f();
        // 功能增强代码
      }
    }
    
    ```

- 可以通过代理模式给接口添加缓存功能。在这节课中，我们又通过装饰者模式给InputStream添加缓存读取数据功能。那对于“添加缓存”这个应用场景来说，我们到底是该用代理模式还是装饰器模式呢？你怎么看待这个问题？

- 粗浅思考：看这个场景中缓存与数据的关系，比如一个网页中大部分元素是不会变的，这时缓存起到的是附加价值：减少网络带宽，这就可以用代理模式来实现缓存功能，而InputStream是专门用来读取数据的，缓存起到的是数据源的问题，相当于对原功能的增强，所以用装饰器模式实现

### 适配器模式（Adapter）

- 适配器的应用场景：解决接口不兼容问题

- 两种实现方式，类适配器和对象适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现

- 用哪种实现？

  - 如果Adaptee接口并不多，那两种实现方式都可以。
  - 如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同，那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。
  - 如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。

- ITarget表示要转化成的接口定义。Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转化成一组符合ITarget接口定义的接口。

  ```java
  // 类适配器: 基于继承
  public interface ITarget {
    void f1();
    void f2();
    void fc();
  }
  
  public class Adaptee {
    public void fa() { //... }
    public void fb() { //... }
    public void fc() { //... }
  }
  
  public class Adaptor extends Adaptee implements ITarget {
    public void f1() {
      super.fa();
    }
    
    public void f2() {
      //...重新实现f2()...
    }
    
    // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
  }
  
  // 对象适配器：基于组合
  public interface ITarget {
    void f1();
    void f2();
    void fc();
  }
  
  public class Adaptee {
    public void fa() { //... }
    public void fb() { //... }
    public void fc() { //... }
  }
  
  public class Adaptor implements ITarget {
    private Adaptee adaptee;
    
    public Adaptor(Adaptee adaptee) {
      this.adaptee = adaptee;
    }
    
    public void f1() {
      adaptee.fa(); //委托给Adaptee
    }
    
    public void f2() {
      //...重新实现f2()...
    }
    
    public void fc() {
      adaptee.fc();
    }
  }
  ```

  

- 什么时候使用？

  - 封装有缺陷的接口设计：比如外部SDK在接口设计有很大缺陷

  - 统一多个类的接口设计：统一后，可以用多态的特性来复用代码逻辑

  - 替换依赖的外部系统：可以减少代码改动量

    ```java
    // 外部系统A
    public interface IA {
      //...
      void fa();
    }
    public class A implements IA {
      //...
      public void fa() { //... }
    }
    // 在我们的项目中，外部系统A的使用示例
    public class Demo {
      private IA a;
      public Demo(IA a) {
        this.a = a;
      }
      //...
    }
    Demo d = new Demo(new A());
    
    // 将外部系统A替换成外部系统B
    public class BAdaptor implemnts IA {
      private B b;
      public BAdaptor(B b) {
        this.b= b;
      }
      public void fa() {
        //...
        b.fb();
      }
    }
    // 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，
    // 只需要将BAdaptor如下注入到Demo即可。
    Demo d = new Demo(new BAdaptor(new B()));
    ```

  - 兼容老版本接口：将内部实现逻辑委托为新的接口实现

  - 适配不同格式的数据

- 适配器例子：Slf4j日志框架
  - 如果开发的项目要给其他项目使用，而两个项目的日志框架并不一致，这就需要两套配置方式，非常麻烦
  
  - Slf4j相当于JDBC规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。
  
  - Slf4j对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义，**slf4j只是一个日志标准，并不是日志系统的具体实现**
  
  - Slf4j不仅仅提供了从其他日志框架到Slf4j的适配器，还提供了反向适配器，也就是从Slf4j到其他日志框架的适配
  
    > Simple Logging Facade for Java (SLF4J)，其实是外观模式/门面模式的典型应用，这里看成适配器也是可以的

### 门面模式（Facade）

- 接口的可复用行与易用性之间的矛盾
  - 为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。
  - 但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。
  - 相反，如果接口粒度设计得太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。

- Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.（门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。）
- 应用场景：
  - 解决易用性：隐藏内部的复杂性，如Linux系统调用函数就可以看作一种“门面”
  - 解决性能问题：比如服务端将多个接口调用替换为一个门面接口调用，减少网络通信成本
  - 解决分布式事务问题：比如使用方调用的两个接口要么同时成功要么同时失败，用门面接口可以支持分布式事务

- 回到开头，接口如何设计？
  - 接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用
  - **尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口**。

- 适配器模式与门面模式的异同：
  - 同：将不好用的接口适配成好用的接口
  - 异：适配器模式解决接口兼容性问题；门面模式运用组合解决接口的易用性问题

### 组合模式（Composite）

- 不常用，主要是用来处理树形结构数据
- Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.（将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。

- 与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。

- 典型例子：

  - 设计一个类表示文件系统中的文件与目录，并统计每个目录下的文件个数与文件总大小，可以用树的数据结构，然后用递归遍历算法实现

    ```java
     public int countNumOfFiles() {
        if (isFile) {
          return 1;
        }
        int numOfFiles = 0;
        for (FileSystemNode fileOrDir : subNodes) {
          numOfFiles += fileOrDir.countNumOfFiles();
        }
        return numOfFiles;
      }
    
      public long countSizeOfFiles() {
        if (isFile) {
          File file = new File(path);
          if (!file.exists()) return 0;
          return file.length();
        }
        long sizeofFiles = 0;
        for (FileSystemNode fileOrDir : subNodes) {
          sizeofFiles += fileOrDir.countSizeOfFiles();
        }
        return sizeofFiles;
      }
    ```

    > 思考题：countNumOfFiles()和countSizeOfFiles()这两个函数实现的效率并不高，因为每次调用它们的时候，都要重新遍历一遍子树。有没有什么办法可以提高这两个函数的执行效率呢（注意：文件系统还会涉及频繁的删除、添加文件操作，也就是对应Directory类中的addSubNode()和removeSubNode()函数）？
    >
    > 个人思考：
    >
    > trade-off，看场景是读多还是写多，如果读多写少，可以尝试下面这种方案：
    >
    > Directory类新增两个成员：numOfFiles, sizeOfFiles，用作缓存，读的时候直接获取即可，File与Dirctory还需要新增一个指向父目录的成员，每当删除or添加文件时，往上递归更新所有目录的numOfFiles、sizeOfFiles
    >
    > 如果读少写多，上述方案的性能瓶颈明显出现在往上递归的更新过程，所以还是原方案较好

  - 开发一个OA系统，员工有工资，员工隶属于部门，部门隶属于上级部门，想要统计每个部门下的工资总数，也可以用树的数据结构，然后递归遍历

### 享元模式（Flyweight）

- 不常用，原理和实现也非常简单，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

- 不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

- 场景：

  - 在线游戏厅有一万个象棋房间，每个房间内的棋盘大小都相同，所以可以把棋子看成享元，设计成独立的的类，供所有棋盘复用，棋盘只需要记录每个棋子的位置信息即可

    > 思考：在棋牌游戏的例子中，有没有必要把位置信息与棋子种类也设计成享元
    >
    > 个人思考：没必要，某个位置与某个棋子的组合有很多种，享元数量太多了，如果每个享元复用的次数不多的话，这样做意义不大

  - 文本编辑器包含字符与格式，格式虽然有无穷中组合，但是一篇文档里面使用的格式不多，可以做出享元，供所有字符使用

- 享元vs单例：享元有点像多例，但应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数
- 享元vs缓存：缓存是为了提供访问效率，而非复用
- 享元vs对象池：池化技术的复用是重复使用，主要目的是节省时间，而享元的复用是指共享使用，主要目的是节省空间

- Java Integer的使用

  - 一个面试题：

  ```java
  Integer i1 = 56; // 自动装箱Integer i = Integer.valueOf(59);
  Integer i2 = 56;
  Integer i3 = 129;
  Integer i4 = 129;
  System.out.println(i1 == i2); // 返回true
  System.out.println(i3 == i4); // 返回false
  ```

  - why：当我们通过自动装箱，也就是调用valueOf()来创建Integer对象的时候，如果要创建的Integer对象的值在-128到127之间，会从IntegerCache类（相当于生成享元对象的工厂类）中直接返回，否则才调用new方法创建。

  - 除了Integer类型之外，其他包装器类型，比如Long、Short、Byte等，也都利用了享元模式来缓存-128到127之间的数据

    > 大多数整型值在这个范围内，如果你发现-128到255之间的数据占内存较多，也可以修改JVM的参数
    >
    > ```shell
    > //方法一：
    > -Djava.lang.Integer.IntegerCache.high=255
    > //方法二：
    > -XX:AutoBoxCacheMax=255
    > ```

- Java String的使用

  - 一个面试题：

    ```java
    String s1 = "小争哥";
    String s2 = "小争哥";
    String s3 = new String("小争哥");
    
    System.out.println(s1 == s2); // true
    System.out.println(s1 == s3); // false
    ```

  - String类也利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”），JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池
  - 与Integer类的区别：Integer类要共享的对象，是在类加载的时候，就集中一次性创建好的，但是String并不知道有哪些字符串，所以是在第一次被用到的时候存储到常量池中，下次再用的时候直接引用常量池中的即可

- 享元模式对JVM的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被JVM垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒可能会浪费更多的内存。

## 设计模式与范式：行为型

**设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。**

### 观察者模式（Observer）

- 非常常用，也叫发布订阅，
- Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.（在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
- 被依赖的对象叫作**被观察者**（Observable），依赖的对象叫作**观察者**（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener

- 观察者模式的"模板"代码

  ```java
  public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers(Message message);
  }
  
  public interface Observer {
    void update(Message message);
  }
  
  public class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<Observer>();
  
    @Override
    public void registerObserver(Observer observer) {
      observers.add(observer);
    }
  
    @Override
    public void removeObserver(Observer observer) {
      observers.remove(observer);
    }
  
    @Override
    public void notifyObservers(Message message) {
      for (Observer observer : observers) {
        observer.update(message);
      }
    }
  
  }
  
  public class ConcreteObserverOne implements Observer {
    @Override
    public void update(Message message) {
      //TODO: 获取消息通知，执行自己的逻辑...
      System.out.println("ConcreteObserverOne is notified.");
    }
  }
  
  public class ConcreteObserverTwo implements Observer {
    @Override
    public void update(Message message) {
      //TODO: 获取消息通知，执行自己的逻辑...
      System.out.println("ConcreteObserverTwo is notified.");
    }
  }
  
  public class Demo {
    public static void main(String[] args) {
      ConcreteSubject subject = new ConcreteSubject();
      subject.registerObserver(new ConcreteObserverOne());
      subject.registerObserver(new ConcreteObserverTwo());
      subject.notifyObservers(new Message());
    }
  }
  ```

- 业务场景举例：开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金，但考虑到以后可能会有其他需求，比如不是发放体验金，而是发放优惠券，并发送一封注册成功的邮件，这时候可以用上观察者模式，因为这些操作都是『观察到』用户注册成功之后才会执行的，它们就相当于观察者

  ```java
  public class UserController {
    private UserService userService; // 依赖注入
    private List<RegObserver> regObservers = new ArrayList<>();
  
    // 一次性设置好，之后也不可能动态的修改
    public void setRegObservers(List<RegObserver> observers) {
      regObservers.addAll(observers);
    }
  
    public Long register(String telephone, String password) {
      //省略校验代码
      long userId = userService.register(telephone, password);
  
      for (RegObserver observer : regObservers) {
        observer.handleRegSuccess(userId);
      }
  
      return userId;
    }
  }
  
  public interface RegObserver {}
  public class RegPromotionObserver implements RegObserver {}
  public class RegNotificationObserver implements RegObserver {}
  ```

- 同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。

- EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，[Google Guava EventBus](https://github.com/google/guava/blob/master/guava/src/com/google/common/eventbus/EventBus.java)就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式

### 模板模式（Template）

- 非常常用，Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.（模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
- 这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。

- 模板模式作用一：复用
  - InputStream的read()函数是一个模板方法，定义了整体流程，并且暴露了一个可以由子类来定制的抽象方法
  - Java AbstractList类中，addAll()调用了需要子类重写的add()方法，所以也是个模板方法
- 模板模式作用二：扩展
  - 不是指代码的可扩展性，而是指框架的可扩展性
  - HttpServlet的service()方法就是一个模板方法，它实现了整个HTTP请求的执行流程，doGet()、doPost()是模板中可以由子类来定制的部分。实际上，这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。
  - JUnit框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown()等），让框架用户可以在这些扩展点上扩展功能。

- 模板模式的『模板』：

  ```java
  public abstract class AbstractClass {
    public final void templateMethod1() {
      //...
      method1();
      //...
    }
    
    protected abstract void method1();
  }
  
  public subClass extends AbstractClass {
    protected void method1() {
      // 延迟到子类执行的方法
    }
  }
  
  ```

- 回调跟模板模式一样，也具有复用和扩展的功能

- 回调（Callback）：回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。

  ```java
  public interface ICallback {
    void methodToCallback();
  }
  
  public class BClass {
    public void process(ICallback callback) {
      //...
      callback.methodToCallback();
      //...
    }
  }
  
  public class AClass {
    public static void main(String[] args) {
      BClass b = new BClass();
      b.process(new ICallback() { //回调对象
        @Override
        public void methodToCallback() {
          System.out.println("Call back me.");
        }
      });
    }
  }
  ```

- 回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数
- 应用举例一：JdbcTemplate
  - Spring提供了很多Template类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用Template（模板）这个单词作为后缀。
  - 使用JdbcTemplate查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的SQL语句、查询结果与User对象之间的映射关系。其他流程性质的代码都封装在了JdbcTemplate类中，不需要我们每次都重新编写

- 应用举例二：setClickListener(）

  - 客户端开发，给空间注册事件监听器，这就很像回调，这是异步的，很像观察者模式

    ```java
    Button button = (Button)findViewById(R.id.button);
    button.setOnClickListener(new OnClickListener() {
      @Override
      public void onClick(View v) {
        System.out.println("I am clicked.");
      }
    });
    ```

- 应用举例三：addShutdownHook()
  - Hook翻译成钩子，Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述
  - JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码

- 模板模式vs回调
  - 从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。
  - 从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。
  - 回调更灵活
    - 像Java这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。
    - 回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。
    - 如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。

### 策略模式（Strategy）

- 这个模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。
- Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.（定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。

- 策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。

  - 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。

  - 策略的创建由工厂类来完成，封装策略创建的细节。

  - 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。

- 策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。

### 职责链（Chain Of Responsibility）

- 比较常用，特别是框架开发，可以基于扩展点定制化框架
- Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.（将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。

- 借助模板模式实现职责链模式（链表管理handler，每个handler需要判断是否要传递给下个handler）：

  ```java
  public abstract class Handler {
    protected Handler successor = null;
  
    public void setSuccessor(Handler successor) {
      this.successor = successor;
    }
  
    public final void handle() {
      boolean handled = doHandle();
      if (successor != null && !handled) {
        successor.handle();
      }
    }
  
    protected abstract boolean doHandle();
  }
  
  public class HandlerA extends Handler {
    @Override
    protected boolean doHandle() {
      boolean handled = false;
      //...
      return handled;
    }
  }
  
  public class HandlerB extends Handler {
    @Override
    protected boolean doHandle() {
      boolean handled = false;
      //...
      return handled;
    }
  }
  
  // 职责链用链表管理
  public class HandlerChain {
    private Handler head = null;
    private Handler tail = null;
  
    public void addHandler(Handler handler) {
      handler.setSuccessor(null);
  
      if (head == null) {
        head = handler;
        tail = handler;
        return;
      }
  
      tail.setSuccessor(handler);
      tail = handler;
    }
  
    public void handle() {
      if (head != null) {
        head.handle();
      }
    }
  }
  
  // 使用举例
  public class Application {
    public static void main(String[] args) {
      HandlerChain chain = new HandlerChain();
      chain.addHandler(new HandlerA());
      chain.addHandler(new HandlerB());
      chain.handle();
    }
  }
  
  ```

  

- 更简洁的职责链实现（通过数组的形式，阻止传递给下一个handler）：

  ```java
  public interface IHandler {
    boolean handle();
  }
  
  public class HandlerA implements IHandler {
    @Override
    public boolean handle() {
      boolean handled = false;
      //...
      return handled;
    }
  }
  
  public class HandlerB implements IHandler {
    @Override
    public boolean handle() {
      boolean handled = false;
      //...
      return handled;
    }
  }
  
  // 职责链由数组管理
  public class HandlerChain {
    private List<IHandler> handlers = new ArrayList<>();
  
    public void addHandler(IHandler handler) {
      this.handlers.add(handler);
    }
  
    public void handle() {
      for (IHandler handler : handlers) {
        boolean handled = handler.handle();
        if (handled) {
          break;
        }
      }
    }
  }
  
  // 使用方式不变
  ```

- 职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。

- 应用场景示例：UGC论坛敏感词过滤，每个过滤规则的处理可以看成handler，职责链非常适合扩展过滤规则，而且当过滤规则是外部提供的，职责链也可以做到不去修改框架代码而去扩展过滤规则，而且职责链也可以配置只选择若干个过滤算法

- Servelt Filter

  - Servlet Filter是Java Servlet规范中定义的组件，翻译成中文就是过滤器，它可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是Servlet规范的一部分，所以，只要是支持Servlet的Web容器（比如，Tomcat、Jetty等），都支持过滤器功能。

  - Servlet Filter添加过滤器非常方便，不需要修改任何代码，定义一个实现javax.servlet.Filter的类，再改改配置就搞定了，完全符合开闭原则。它就是使用职责链模式的

    ![image-20220109181814078](https://tva1.sinaimg.cn/large/008i3skNgy1gy7l95dh2jj318e0jot9y.jpg)

- Spring Interceptor

  - 是Spring MVC框架的一部分，由Spring MVC框架来提供实现。客户端发送的请求，会先经过Servlet Filter，然后再经过Spring Interceptor，最后到达具体的业务代码中。

  - 过滤器与拦截器虽然名字不同，但都是职责链的handler的化名，取了个与使用场景相关的名字而已

    ![image-20220109181832278](https://tva1.sinaimg.cn/large/008i3skNgy1gy7l9ih2dlj318o0dq0ts.jpg)

- Dubbo Filter、Netty ChannelPipeline也是职责链模式的使用案例

### 状态模式（State）

- 不常用，但是有时候能发挥很大作用
- 状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。
  - 第一种实现方式叫分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。
  - 第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。
  - 第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。
- 实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。

### 迭代器模式（Iterator）

- 迭代器模式。它用来遍历集合对象，很多编程语言把迭代器作为基础类库，程序员只需要直接使用即可，但要知其所以然

- 迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及**容器**和**容器迭代器**两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类

  ![image-20220109183502795](https://tva1.sinaimg.cn/large/008i3skNgy1gy7lqlutaoj318k0ks3zx.jpg)

- Iterator接口定义

  ```java
  // 接口定义方式一
  public interface Iterator<E> {
    boolean hasNext();
    void next(); // 游标后移一位元素
    E currentItem(); // 返回当前游标指向的元素
  }
  
  // 接口定义方式二
  public interface Iterator<E> {
    boolean hasNext();
    E next(); // ，返回当前元素与后移一位
  }
  ```

- ArrayList的迭代器示例

  ```java
  public interface List<E> {
    Iterator iterator();
    //...省略其他接口函数...
  }
  
  public class ArrayList<E> implements List<E> {
    //...
    public Iterator iterator() {
      return new ArrayIterator(this); // 封装迭代器的创建细节
    }
    //...省略其他代码
  }
  
  public class Demo {
    public static void main(String[] args) {
      List<String> names = new ArrayList<>();
      names.add("xzg");
      names.add("wang");
      names.add("zheng");
      
      Iterator<String> iterator = names.iterator();
      while (iterator.hasNext()) {
        System.out.println(iterator.currentItem());
        iterator.next();
      }
    }
  }
  ```

  ![image-20220109184157677](https://tva1.sinaimg.cn/large/008i3skNgy1gy7lxt0sgyj318q0oidht.jpg)

- 为什么要迭代器？
  - 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；
    - 对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。
    - 应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义DFSIterator、BFSIterator两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。
  - 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；
  - 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。

- Java迭代器失效
  - 理解：
    - 怎么确定在遍历时候，集合有没有增删元素呢？我们在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给modCount加1。当通过调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的expectedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，我们都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。
    - 如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的bug。
  - Java迭代器类中还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。
    - 迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到
  - 可参考：[java迭代器失效](https://blog.csdn.net/wxlfight/article/details/8609115)

- 如何实现一个支持“快照”功能的迭代器模式？
  - 所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。
  - 低效的实现：在迭代器类中定义一个成员变量snapshot来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行
  - 高效的实现：
    - 在容器中，为每个元素保存两个时间戳，一个是添加时间戳addTimestamp，一个是删除时间戳delTimestamp。当元素被加入到集合中的时候，我们将addTimestamp设置为当前时间，将delTimestamp设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将delTimestamp更新为当前时间，表示已经被删除。注意，这里只是标记删除，而非真正将它从容器中删除。
    - 同时，每个迭代器也保存一个迭代器创建时间戳snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足addTimestamp<snapshotTimestamp<delTimestamp的元素，才是属于这个迭代器的快照。
    - 如果元素的addTimestamp>snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的delTimestamp<snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。

### 访问者模式（Visitor）

- 非常不常用，难理解，难实现，还会导致代码的可读性、可维护性变差
- Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.（允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。

- 对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。
- 多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。
  - Double Dispatch（双分派）
    - 在面向对象编程语言中，方法调用可以理解为一种消息传递（Dispatch）。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名和方法参数。
    - Double Dispatch指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。
    - Single Dispatch之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。
    - 当前主流编程语言都只支持Single Dispatch，不支持Double Dispatch。
    - Java支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管Java支持函数重载，但Java设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java语言只支持Single Dispatch。

### 备忘录模式（Memento）

- 又叫快照模式，理解、掌握起来不难，代码实现比较灵活，应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。

- Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.（在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。


- 备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。

- 如何优化内存与时间消耗
  - 低频率全量备份”和“高频率增量备份”相结合的方法：当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。

### 命令模式（Command）

- 不常用，难理解，特定场景才用到
- The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.（命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。
- 落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。我们知道，C语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。
- 当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。

- 命令模式跟策略模式、工厂模式非常相似，实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。

### 解释器模式（Interpreter）

- 不常用，难理解，特定场景才用到
- 解释器模式用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。

- Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.（：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。
- 从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”
- 解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。
- 应用场景：实现一个自定义接口告警规则

### 中介模式（Mediator）

- 不常用，应用场景比较特殊、有限，但理解不难

- Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.（中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。
- 实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）
- 坏处是中介类有可能会变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。

- 中介模式与观察者模式的区别
  - 观察者模式的关系往往都是单向的，交互关系有条理
  - 而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。

## 复习设计模式

### 1.单例模式

单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。

尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：

- 单例对OOP特性的支持不友好
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数

那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。

有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。

除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。这里我就不带你回顾了，你可以自己回忆一下。

### 2.工厂模式

工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。

工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。

当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。

详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI框架已经成为了我们平时开发的必备框架，在专栏中，我还带你实现了一个简单的DI框架，你可以再回过头去看看。

### 3.建造者模式

建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。

如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。

- 我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。
- 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
- 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。

### 4.原型模式

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。

原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。

如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。

### 1.代理模式

代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。

静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。

### 2.桥接模式

桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。

桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。

对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。

### 3.装饰器模式

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。

### 4.适配器模式

代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这5种场景：

- 封装有缺陷的接口设计
- 统一多个类的接口设计
- 替换依赖的外部系统
- 兼容老版本接口
- 适配不同格式的数据

### 5.门面模式

门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。

### 6.组合模式

组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。

组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。

### 7.享元模式

所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。

### 1.观察者模式

观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。

不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。

框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成EventBus框架来达到这样的效果。EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。

### 2.模板模式

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。

模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如JdbcTemplate就是用了回调。

相对于普通的函数调用，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。

回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。

### 3.策略模式

策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。

策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。

在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。

### 4.职责链模式

在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。

在GoF的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。

职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。

### 5.迭代器模式

迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。

遍历集合一般有三种方式：for循环、foreach循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于for循环遍历，利用迭代器来遍历有3个优势：

- 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；
- 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；
- 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。

在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java语言就是采用的这种解决方案。增删元素之后，我们选择fail-fast解决方式，让遍历操作直接抛出运行时异常。

### 6.状态模式

状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由3个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。

针对状态机，我们总结了三种实现方式。

第一种实现方式叫分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。

第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。

第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。

### 7.访问者模式

访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。

对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到Double Disptach。如果某种语言支持Double Dispatch，那就不需要访问者模式了。

正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。

### 8.备忘录模式

备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。

备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。

对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。

### 9.命令模式

命令模式在平时工作中并不常用，你稍微了解一下就可以。

落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。

命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。

### 10.解释器模式

解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。

要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。

解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。

### 11.中介模式

中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。

观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。

## 剖析Java SDK源码学习设计模式

### Calendar类

工厂模式

- Calendar类提供了大量跟日期相关的功能代码，同时，又提供了一个getInstance()工厂方法，用来根据不同的TimeZone和Locale创建不同的Calendar子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便我们去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以Factory作为后缀来命名。

建造者模式

- 建造者模式有两种实现方法，一种是单独定义一个Builder类，另一种是将Builder实现为原始类的内部类。Calendar就采用了第二种实现思路。
- 在建造者类的build()方法中，前半部分是工厂方法的代码实现，后半部分才是真正的建造者模式的代码实现

### Collections类

装饰器模式

- Collections类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器，比如通过unmodifiableColletion()静态方法，来创建UnmodifiableCollection类对象。而这些容器类中的UnmodifiableCollection类、CheckedCollection和SynchronizedCollection类，就是针对Collection类的装饰器类。

- UnmodifiableCollection是Collection类的功能增强，而且最关键的是：UnmodifiableCollection的构造函数接收一个Collection类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如add()函数）或者简单封装（比如stream()函数）

适配器模式

- 老版本的JDK提供了Enumeration类来遍历容器。新版本的JDK用Iterator类替代Enumeration类来遍历容器。
- 在新版本的JDK中，Enumeration类是适配器类。它适配的是客户端代码（使用Enumeration类）和新版本JDK中新的迭代器Iterator类。不过，从代码实现的角度来说，这个适配器模式的代码实现，跟经典的适配器模式的代码实现，差别稍微有点大。enumeration()静态函数的逻辑和Enumeration适配器类的代码耦合在一起，enumeration()静态函数直接通过new的方式创建了匿名类对象

模板模式

- Collections.sort()实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果我们把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那我们就可以把它看作模板模式。

观察者模式

- 除了使用Google Guava的EventBus框架，我们可以简单使用java.util.Observable和java.util.Observer

### Runtime类

单例模式

- JDK中java.lang.Runtime类就是一个单例类，添加shutdown hook就是通过这个类来实现的。

- 每个Java应用在运行时会启动一个JVM进程，每个JVM进程都只对应一个Runtime实例，用于查看JVM状态以及控制JVM行为。进程内唯一，所以比较适合设计为单例。在编程的时候，我们不能自己去实例化一个Runtime对象，只能通过getRuntime()静态方法来获得。

## 学习Google Guava

- 在业务开发中，跟业务无关的通用功能模块，常见的一般有三类：类库（library）、框架（framework）、功能组件（component）等。

### Builder模式在Guava中的应用

- 系统内部构建一个内存缓存，从零用HashMap开发成本较高，可以直接使用com.google.common.cache.*

- 创建缓存类使用了建造者模式，必须使用Builder模式的主要原因是，在真正构造Cache对象的时候，我们必须做一些必要的参数校验，也就是build()函数中前两行代码要做的工作

  ```java
      Cache<String, String> cache = CacheBuilder.newBuilder()
              .initialCapacity(100)
              .maximumSize(1000)
              .expireAfterWrite(10, TimeUnit.MINUTES)
              .build();
  
      cache.put("key1", "value1");
      String value = cache.getIfPresent("key1");
  ```

### Wrappe模式在Guava中的应用

- 在Google Guava的collection包路径下，有一组以Forwarding开头命名的类
- 代理模式、装饰器、适配器模式可以统称为Wrapper模式，通过Wrapper类二次封装原始类。它们的代码实现也很相似，都可以通过组合的方式，将Wrapper类的函数实现委托给原始类的函数来实现。

### Immutable在Guava中的应用

- Immutable模式，中文叫作不变模式，它并不属于经典的23种设计模式，但也值得学习
- 一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是**不变类**（Immutable Class），对象就是**不变对象**（Immutable Object）。在Java中，最常用的不变类就是String类，String对象一旦创建之后就无法改变。
- 不变模式可以分为两类，一类是普通不变模式，另一类是深度不变模式（Deeply Immutable Pattern）。普通的不变模式指的是，对象中包含的引用对象是可以改变的。如果不特别说明，通常我们所说的不变模式，指的就是普通的不变模式。
- 因为数据不变，所以不存在并发读写问题，因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式。
- Google Guava针对集合类（Collection、List、Set、Map…）提供了对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。Google Guava提供的不变集合中的对象不会增删，但是对象的成员变量（或叫属性值）是可以改变的。Java JDK也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）

### 函数式编程

- 函数式编程因其编程的特殊性，仅在科学计算、数据处理、统计分析等领域，才能更好地发挥它的优势。
- 严格上来讲，函数式编程中的“函数”，并不是指我们编程语言中的“函数”概念，而是指数学“函数”或者“表达式”（比如，y=f(x)）。不过，在编程实现的时候，对于数学“函数”或“表达式”，我们一般习惯性地将它们设计成函数。
- 无状态：函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。

- 面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数

## 剖析Spring框架

- 我们常说的Spring框架，是指Spring Framework基础框架。Spring Framework是整个Spring生态（也被称作Spring全家桶）的基石，还有整合更多功能的框架，比如Spring Boot、Spring Cloud。

- 框架的侵入性是衡量框架好坏的重要指标。所谓低侵入指的是，框架代码很少耦合在业务代码中。低侵入意味着，当我们要替换一个框架的时候，对原有的业务代码改动会很少
  - Spring提供的IOC容器，在不需要Bean继承任何父类或者实现任何接口的情况下，仅仅通过配置，就能将它们纳入进Spring的管理中。如果我们换一个IOC容器，也只是重新配置一下就可以了，原有的Bean都不需要任何修改。
  - 除此之外，Spring提供的AOP功能，也体现了低侵入的特性。在项目中，对于非业务功能，比如请求日志、数据采点、安全校验、事务等等，我们没必要将它们侵入进业务代码中

- 模块化、轻量级

- 再封装、再抽象：Spring不仅仅提供了各种Java项目开发的常用功能模块，而且还对市面上主流的中间件、系统的访问类库，做了进一步的封装和抽象，提供了更高层次、更统一的访问接口。

### 观察者模式在Spring的应用

- Spring也提供了观察者模式的实现框架
- Spring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）

### 模板模式在Spring中的应用

- Spring利用模板模式让用户定制Bean的创建过程
- Bean的创建包含两个大的步骤，对象的创建和对象的初始化。其中，对象的初始化又可以分解为3个小的步骤：初始化前置操作、初始化、初始化后置操作。
  - 对象的创建是通过反射来动态生成对象，而不是new方法。
  - Spring允许用户在配置文件中init-method属性来指定初始化函数。但是初始化函数并不固定，由用户随意定义，这就需要Spring通过反射，在运行时动态地调用这个初始化函数。而反射又会影响代码执行的性能
  - Spring提供了另外一个定义初始化函数的方法，那就是让类实现Initializingbean接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet()函数）。Spring在初始化Bean的时候，可以直接通过bean.afterPropertiesSet()的方式，调用Bean对象上的这个函数，而不需要使用反射来调用了。
  - 实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似我们前面讲到的Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。

### 适配器模式在Spring中的应用

- 在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL
- Spring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等

### 策略模式在Spring中的应用

- Spring AOP是通过动态代理来实现的。熟悉Java的同学应该知道，具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。

- 前者需要被代理的类有抽象的接口定义，后者不需要。针对不同的被代理类，Spring会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景。

### 组合模式在Spring中的应用

- Spring Cache提供了一套抽象的Cache接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring中针对不同缓存实现的不同缓存访问类，都依赖这个接口
- 叶子节点包含的是它所管理的Cache对象，中间节点包含的是其他CacheManager管理器，既可以是CompositeCacheManager，也可以是具体的管理器，比如EhCacheManager、RedisManager等。

### 装饰器模式在Spring中的应用

- TransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。

### 工厂模式在Spring中的应用

- 在Spring中，工厂模式最经典的应用莫过于实现IOC容器，对应的Spring源码主要是BeanFactory类和ApplicationContext相关类

### 解释器模式

- SpEL，全称叫Spring Expression Language，是Spring中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring就能解析出表达式的含义。实际上，这就是我们前面讲到的解释器模式的典型应用场景。

## 剖析MyBatis

- MyBatis是一个ORM（Object Relational Mapping，对象-关系映射）框架。ORM框架主要是根据类和数据库表之间的映射关系，帮助程序员自动实现对象与数据库中数据之间的互相转化。有名的ORM框架还有Hibernate、TopLink等。
- JdbcTemplate提供的功能最简单，易用性最差，性能损耗最少，用它编程性能最好。
- Hibernate提供的功能最完善，易用性最好，但相对来说性能损耗就最高了。
- MyBatis介于两者中间，在易用性、性能、灵活性三个方面做到了权衡。它支撑程序员自己编写SQL，能够延续程序员对SQL知识的积累。相对于完全黑盒子的Hibernate，很多程序员反倒是更加喜欢MyBatis这种半透明的框架

### 职责链与代理模式实现MyBatis的Plugin

- 实际上，MyBatis Plugin跟Servlet Filter、Spring Interceptor的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。
- Servlet Filter主要拦截Servlet请求，Spring Interceptor主要拦截Spring管理的Bean方法（比如Controller类的方法等），而MyBatis Plugin主要拦截的是MyBatis在执行SQL的过程中涉及的一些方法。
- 在这三种应用场景中，职责链模式的实现思路都不大一样。其中，Servlet Filter采用递归来实现拦截方法前后添加逻辑。Spring Interceptor的实现比较简单，把拦截方法前后要添加的逻辑放到两个方法中实现。MyBatis Plugin采用嵌套动态代理的方法来实现，实现思路很有技巧。
- 设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式。不过MyBatis它是借助动态代理模式来实现的职责链
- 除了统计SQL的执行耗时，利用MyBatis Plugin，我们还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等

### 模板模式与普通继承

- Executor相关的类主要是用来执行SQL。其中，Executor本身是一个接口；BaseExecutor是一个抽象类，实现了Executor接口；而BatchExecutor、SimpleExecutor、ReuseExecutor三个类继承BaseExecutor抽象类
- 模板模式基于继承来实现代码复用。如果抽象类中包含模板方法，模板方法调用有待子类实现的抽象方法，那这一般就是模板模式的代码实现。而且，在命名上，模板方法与抽象方法一般是一一对应的，抽象方法在模板方法前面多一个“do”，比如，在BaseExecutor类中，其中一个模板方法叫update()，那对应的抽象方法就叫doUpdate()。

### 装饰器模式

- 在MyBatis中，缓存功能由接口Cache定义。PerpetualCache类是最基础的缓存类，是一个大小无限的缓存。除此之外，MyBatis还设计了9个包裹PerpetualCache类的装饰器类，用来实现功能增强。它们分别是：FifoCache、LoggingCache、LruCache、ScheduledCache、SerializedCache、SoftCache、SynchronizedCache、WeakCache、TransactionalCache。
- 之所以MyBatis采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸。

### 适配器模式在MyBatis的应用

- Slf4j框架为了统一各个不同的日志框架（Log4j、JCL、Logback等），提供了一套统一的日志接口。不过，MyBatis并没有直接使用Slf4j提供的统一日志规范，而是自己定义了一套日志访问接口
