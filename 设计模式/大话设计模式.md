## 桥接模式

适配器：改变已有的两个接口，让他们相容。

桥接模式：分离抽象化和实现，使两者的接口可以不同，目的是分离。

共同点：桥接和适配器都是让两个东西配合工作。

不同点：出发点不同

- 适配器：改变已有的两个接口，让他们相容。
- 桥接模式：分离抽象化和实现，使两者的接口可以不同，目的是分离

桥接是先有桥，才有两端的东西，适配是先有两边的东西，才有适配器，桥接是在桥好了之后，两边的东西还可以变化

### 何时使用

- 在抽象化角色和具体化角色之间增加更多的灵活性
- 实现化角色不能影响客户端

## 责任链模式

- 纯责任链模式要求具体处理必须在两个行为中二选一：承担责任 or 责任推给下家，并且最后一定会被某一个处理者对象所接受
- 责任链模式减低了发出命令的对象和处理命令的对象之间的耦合
- 一个链可以是一条线，一个树，也可以是一个环。链的拓扑结构可以是单连通的或多连通的，责任链模式并不指定责任链的拓扑结构。但是责任链模式要求在同一个时间里，命令只可以被传给一个下家（或被处理掉）；而不可以传给多于一个下家。

### 举例：击鼓传花

- 客户端不知道最后处理者是谁
- Handler是个抽象的类，定义了抽象的handler方法，具体的ConcretHandler继承了Handler，并重写了父类的方法

![image-20211215233447555](https://tva1.sinaimg.cn/large/008i3skNly1gxexwv2engj30v80l6tab.jpg)

```java
public class Handler
{
  public void handleRequest()
  {
    if (successor != null)
    {
    	successor.handleRequest();
    }
    // Write your code here
  }
  public void setSuccessor(Handler successor)
  {
    this.successor = successor;
  }
  public Handler getSuccessor()
  {
    return successor;
  }
  private Handler successor;
}

public class ConcreteHandler extends Handler
{
  public void handleRequest()
  {
    if (getSuccessor() != null)
    {
      getSuccessor().handleRequest();
    }
    if (successor != null)
    {
      successor.handleRequest();
    }
    // Write your code here
  }
}
```

### 什么时候使用

- 事先并不知道到底由哪一个处理者对象处理这个请求
- 当处理一个请求的处理者对象集合需要动态地指定时。

## 单体模式/单例模式

- 对象只要利用自己的属性完成了自己的任务
- 将类的责任集中到唯一的单体对象中，确保该类只有一个实例，并且为该类提供一个全局访问点。这就是单体模式的目的

- 分为饿汉、懒汉

## 观察者模式

- 观察者模式又名发布订阅模式。定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
- 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节，观察者模式提供了一种对象设计，让主题和观察者之间松耦合
  - 主题只需要知道观察者实现了某个接口，不需要知道观察者的具体类是什么
  - 任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现Observer接口的对象列表
  - 有新类型的观察者出现时，主题的代码不需要修改。只要在新类里实现观察者接口，然后注册为观察者即可
  - 改变主题或观察者任何一方，并不会影响另一方，只要他们之间的接口没有改变即可

角色分工

- 1、抽象目标角色：目标角色知道它的观察者，可以有任意多个观察者观察同一个目标。并且提供注册和删除观察者对象的接口。目标角色往往由抽象类或者接口来实现。
- 2、抽象观察者角色：为那些在目标发生改变时需要获得通知的对象定义一个更新接口。抽象观察者角色主要由抽象类或者接口来实现。
- 3、具体目标角色：将有关状态存入各个具体观察者角色对象。当它的状态发生改变时, 向它的各个观察者发出通知。
- 4、具体观察者角色：存储有关状态，这些状态应与目标的状态保持一致。实现观察者角色的更新接口以使自身状态与目标的状态保持一致。在这个角色内也可以维护一个指向具体目标角色对象的引用

![image-20211216005117248](https://tva1.sinaimg.cn/large/008i3skNly1gxf053bj6sj30u00vomz0.jpg)

典型应用

- 1、侦听事件驱动程序设计中的外部事件
- 2、侦听/监视某个对象的状态变化
- 3、发布者/订阅者(publisher/subscriber)模型中，当一个外部事件（新的产品，消息的出现等等）被触发时，通知邮件列表中的订阅者。”

通信有两个版本

- 拉模式：目标角色发生变化后，仅仅告诉观察者橘色『我变化了』，变化的信息是观察者角色主动从目标角色中‘拉’出来的
- 推模式：目标角色发生变化后，通知发生变化的同时，还将变化的细节传递到观察者角色中去