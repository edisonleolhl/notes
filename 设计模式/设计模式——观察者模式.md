观察者（Observer）模式
##走进观察者模式
- 首先，先思考订阅报纸是怎么回事

	1. 报社的业务就是出版报纸，并把报纸送给那些订阅报纸的人
	
	2. 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送一份来，只要你是他们的客户，你就会一直收到新报纸
	
	3. 当你不想订报纸的时候，取消订阅，你就再也不会收到他们新出版的报纸了
	
	4. 只要报社还在运营，总会有人向他们订阅报纸或取消订阅报纸
	
- 上面这些话看起来像是废话，但是得把他们拆开来看，观察者模式的思想就是这样的

- 在观察者模式中，报社（出版者）称为“**主题”（subject）**，订阅者称为**“观察者”（Observer）**

---

- ###定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新

- 如何理解一对多的关系？

	利用观察者模式，主题是具有状态的对象，并且可以控制这些状态。也就是说，有“一个”具有状态的主题。另一方面，观察者使用这些状态，虽然这些状态并不属于他们。有许多依赖观察者，以来主题来通知他们状态改变了。这就产生了关系：“一个”主题对“多个”观察者的关系。

- 依赖如何产生？

	因为主题才是真正拥有数据的实体，观察者是主题的依赖者，当数据变化时更新，这样比起让许多对象控制同一份数据来，可以得到更干净的 OO （object oriented）设计

##设计观察者模式
简单设计经典的观察者模式

- 首先，定义主题接口，该接口内至少提供3个方法：registerObserver()、removeObserver()、notifyObserver()

	顾名思义，对象可以注册（register）成为观察者，对象还可以把自己移除（remove），主题还得通知（notify）依赖他的观察者们

- 定义了主题接口，接下来可以定义一些具体主题来实现（implements）主题接口，因为是实现接口，所以必须重写接口中的所有定义方法（注册、移除、通知），当然具体主题类还可以有 setState()、getState() 方法

- 主题部分搞定了，接下来是观察者部分，先定义一个观察者接口，接口中至少要提供 update() 方法，当主题状态改变时，该方法会被调用

- 还可以定义一些具体的观察者类来实现观察者接口，在这些类中，必须重写观察者接口中的 update() 方法，以应对不同的业务需求

- UML 类图（圆点表示接口）：

	![](http://upload-images.jianshu.io/upload_images/2106579-b799ecfab7e315ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##松耦合
- 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节，观察者模式提供了一种对象设计，让主题和观察者之间松耦合

- 对于主题来说，主题只知道观察者实现了某个接口（也就是 Observer）接口，主题不需要知道观察者的具体是谁、做了些什么或其他任何细节

- 任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现 Observer 接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的，也可以在任何时候删除某些观察者

- 有新类型的观察者出现时，主题的代码不需要修改。也就是说，如果有一个新的具体类想成为某个主题的观察者，我们不需要为了兼容而修改主题的代码，只需要在新的类里实现此观察者接口，然后注册为观察者即可，主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象

- 我们可以独立地复用主题或观察者，如果我们在其他地方需要使用主题或观察者，可以轻易地复用，因为二者并非紧耦合

- 改变主题或观察者其中一方，并不会影响另一方，因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由地改变他们

- **因为对象之间的互相依赖降到了最低，所以松耦合的设计能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低**

##模拟案例：气象观测站
- 此系统的三个部分是气象站（获取实际气象数据的屋里装置）、WeatherData 对象（追踪来自气象站的数据，并更新公告板）和公告板（显示目前天气状况给用户看）

- WeatherData 对象知道如何和物理气象站联系以取得更新的数据，WeatherData 对象会随即更新三个公告板的显示：目前状况（温度、湿度、气压）、气象统计和天气预报

- 

- UML 类图：

##使用 Java 内置的观察者模式
- java.util 包内包含了最基本的 Observer 接口与 Observable 类，这和之前设计的   Observer 接口与 Subject 接口很相似，区别是 Subject 接口变为了 Observable （可观察者），本来具体主题是要实现 Subject 接口的，现在变成了扩展（继承） Observable 类

- 如何把对象变成观察者？

	如同之前一样，实现观察者接口（现在是实现 java 内置的 java.util.Observer 接口），然后调用 某个 Observable 对象的 addObserver() 方法，当不想再当观察者时，调用 deleteObserver() 方法就可以了

- 可观察者如何送出通知？

	首先，需要继承 java.util.Observable 接口产生“可观察者”类，然后需要两个步骤：
	
	1. 先调用 setChanged() 方法，标记状态已经改变的事实

	2. 然后调用 notifyObservers() 方法 或者 notifyObservers(Object arg）

- 观察者如何接受？

	同以前一样，观察者实现了更新的方法，但是方法的签名不太一样：

		update(Observable o, Object arg)

	o 主题本身当作第一个变量，好让观察者知道哪个主题通知它

	arg 这正是传入 notifyObservers() 的数据对象

	如果你想推（push）数据给观察者，你可以把数据当作数据对象传送给 notifyObservers(arg) 方法，否则，观察者就必须从可观察者对象中拉（pull）数据

- UML 类图：

	![](http://upload-images.jianshu.io/upload_images/2106579-1518ca104dda6ed0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 注意：有多个观察者时，不能依赖特定的通知次序

###java.util.Observable 的黑暗面
- 首先它是一个类，而不是一个接口，甚至它都没有实现一个接口

- 因为它是一个类，所以必须设计一个类来继承它，又因为 Java 只支持单继承，这就限制了 Observer 的复用潜力

- 因为没有 Observable 接口，你无法建立自己的实现和 Java api 相配合
