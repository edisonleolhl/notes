# C++查漏补缺

## 基本语言

### 说一说Static关键字的作用

1. 全局静态变量，存储在静态存储区，未经初始化的变量自动初始为0（对象的话是任意的），其他文件不可见
2. 局部静态变量，存储在静态存储区，未经初始化的变量自动初始为0（对象的话是任意的），作用域仍为局部作用域，当定义它的函数或语句块结束时，局部静态变量不销毁，而是驻留在内存中，只不过不能进行访问，当下次再进入函数或语句块时，局部静态变量的值不改变。
3. 静态函数，不能被其他文件所用，建议不要在头文件声明static全局函数，不要在cpp文件内声明非static全局函数，如果要在多个cpp文件内复用，就把声明放在头文件里面，否则cpp内部的声明需要加上static修饰
4. 类的静态成员，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。
5. 类的静态函数，同上，都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能访问类的非静态成员，可以访问类的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

### 说一说extern关键字的作用

1. extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
2. 在函数前加上`extern "C"`，告诉编译器要用C的规则去翻译函数名，因为C不支持函数重载而C++支持函数重载，所以C++会将函数名和参数联合起来生成一个中间的函数名称

### 说一说四种cast转换

1. const_cast，用于将const变量转化为非const变量
2. static_cast，用于各种隐式转换，基础类型转换，如非const转const，void*转指针，用于多态向上转换，如果向下转换能成功但不安全
3. dynamic_cast，动态类型转换。只能用于含有虚函数的类，用于类层次间的向上（子类向父类）和向下（父类向子类）转化
4. reinterpret_cast，几乎什么都可以转，比如int转指针，但可能会出问题，尽量少用

### 指针和引用的区别

1. 引用可以说是别名，指针有自己的存储空间，里面存储的是所指对象的地址
2. 引用必须初始化，指针不必须初始化
3. 引用初始化后不能更改引用的对象，指针初始化后可以更改指向的对象
4. 使用sizeof运算符看指针是4字节（32位机器）或8字节（64位机器），而用sizeof运算符看引用则取决于被引用对象的大小
5. 指针需要解引用才能对所指对象进行操作，而引用可以直接修改
6. 有const指针，没有const引用
7. 指针可以进行自增或自减操作，可以访问原对象相邻存储空间的内容，引用只能固定引用
8. 返回动态内存分配的对象或内存，必须用指针，用引用有可能内存泄露

### 说一说智能指针

智能指针是一个类似指针的类，提供了内存管理的功能，当指针不再被使用时，它指向的内存会自动被释放，这就比原生指针要好，原生指针有可能会因为忘记释放所申请的空间，而造成内存泄漏，而用智能指针就没这个顾虑。C++11支持shared_ptr, weak_ptr, unique_ptr，auto_ptr（被弃用）

auto_ptr采取所有权模式，可以被其他auto_ptr剥夺（转移），所以很容易引起内存泄露
shared_ptr是共享，多个智能指针可以指向相同对象，该对象及其相关资源会在“最后一个引用被销毁”时释放，采用引用计数统计被几个智能指针共享
unique_ptr是独占式拥有，保证同一时间内只有一个智能指针可以指向该对象
weak_ptr是一种弱引用，指向shared_ptr所管理的对象，可从一个shared_ptr或另一个weak_ptr来构造，它的构造和析构不会引起引用计数的增加或减少

### 智能指针也会发生内存泄漏吗；如果是，有什么手段避免

两个shared_ptr相互引用时会发生循环引用，使引用计数失效，从而导致内存泄露

weak_ptr弱指针可以解决这个问题，weak_ptr的构造和析构不会影响引用计数，它指向shared_ptr所管理的对象，也可以检测到所管理的对象是否已经被释放，从而避免非法访问

### 数组和指针的区别

1. 指针是单个空间，存储的是所指对象的地址；数组可以有若干单位的空间，存储对象本身； 可以有指向数组的指针，也可以有每个单元都是指针的数组
2. 指针间接访问对象，得先解引用，指针可以直接访问
3. 当指针指向数组时，可以用自增自减在数组元素上移动，但若要访问还是需要解引用
4. 当数组作为函数参数传入时，会自动变化为指针，指向数组首位

### 野指针是什么

指向的位置是不可知的，随机的，没有限制的，不可预测的

1. 未初始化的指针
2. 指针释放后未置空
3. 指针操作超越边界，如访问数组时

### 说一下函数指针

函数指针是指向函数的指针，声明如：`int (*p)(int a, int b);`，每个函数在编译时都有一个入口地址，这在汇编代码里面看的十分清楚，函数指针存储的就是这种入口地址的值，可以直接用函数指针调用函数

### 右值引用是什么，跟左值引用又有什么区别

左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。

右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。

右值引用是C++11中引入的新特性, 它实现了转移语义和精确传递。右值的主要目的有两个方面：

1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
2. 能够更简洁明确地定义泛型函数。

右值引用和左值引用的区别：

1. 左值可以寻址，而右值不可以。
2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
3. 左值可变,右值不可变

### C++11有哪些新特性

auto关键字：编译器根据初始值自动推导出类型，但是不能用于函数传参以及数组类型的推导

nullptr：一种特殊的空指针类型，能转换成其他任意类型的指针，而NULL一般被宏定义为0，遇到重载时可能会出现问题

decltype：查询表达式的类型，不会对表达式求值，经常与auto配合追踪函数的返回值类型

基于范围的for循环: `for(auto &v : vec){...}`

匿名函数 Lambda: `[capture list] (params list) mutable exception-> return type { function body }`，值捕获、引用捕获、隐式捕获

智能指针：新增了shared_ptr、unique_ptr、weak_ptr，用于解决内存管理的问题

初始化列表：使用初始化列表来对类进行初始化

可变参数模板：对参数进行了高度泛化，能表示0到任意个数、任意类型的参数，`template <class... T> void f(T... args);`

右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率

新增正则表达式库

新增STL容器array以及tuple

## 类和数据抽象

### struct和class的区别

struct与class一样，可以包括成员函数，可以实现继承，可以实现多态。不同点在于

1. 默认的继承访问权。class默认的是private，strcut默认的是public，继承访问权取决于子类而不是基类，比如struct继承class则默认是public继承
2. 默认访问权限：struct作为数据结构的实现体，它默认的成员访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。
3. “class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数

最好的建议就是：当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。

### C++中类的成员访问限定符

分为private、public、protected，控制成员变量和成员函数的访问权限，C++类本身没有公私之分

在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员，但是protected属性的成员在派生类内部可以访问

### C++中的三种继承方式

继承方式是为了控制子类(也称派生类)的调用方(也叫用户)对父类(也称基类)的访问权限。

1. 使用private继承,父类的所有方法在子类中变为private;
2. 使用protected继承,父类的protected和public方法在子类中变为protected，private方法不变;
3. 使用public继承,父类中的方法属性不发生改变;

### C++类内可以定义引用数据成员吗

1. 可以，但必须在定义时初始化
2. 因此不能用默认的构造函数，必须自己设计构造函数
3. 且构造函数的形参必须为引用类型，引用型数据成员必须在初始化列表里初始化，不能在函数体里初始化，因为在函数体内修改引用型数据成员，相当于赋值，而引用不能赋值

### C++中析构函数的作用

1. 析构函数与构造函数对应，当对象结束其生命周期时，会自动执行析构函数
2. 如果用户没有定义析构函数，则编译器会自动生成一个合成的/缺省的析构函数，即使用户自定义了析构函数，合成的析构函数还是有的
3. 如果类中有指针，并且在使用的过程中动态申请了内存，那么最好就应该显式定义析构函数，在其中释放申请的内存空间
4. 类析构顺序：子类析构函数-》对象成员析构函数-》父类析构函数

### C++多态怎么理解

主要分为编译时多态（早绑定）和运行时多态（晚绑定），编译时多态通过泛型模板和重载实现，运行时多态通过虚函数实现

### 虚函数是什么，虚函数怎么实现运行时多态的

在有虚函数的类中，类的对象的头部是一个虚函数表的指针，虚函数表中放了虚函数的地址，子类继承父类时也会继承虚函数表，但是当子类重写虚函数数时，虚函数表中的地址会替换为重写的函数地址。使用虚函数会增加内存开销。

### 重载和覆盖区别

重载是指多个同名函数之间的一种关系，这些同名函数在参数列表上有所不同（个数、类型、顺序），调用函数时，编译器会选择匹配的函数执行，仅有返回值不同的两个同名函数不能重载，const和非const也可以重载，

覆盖发生在子类继承父类的情况下，父类的函数是虚函数，子类重新定义了这个虚函数（不加virtual关键字也是虚函数），这就是覆盖

### 静态函数和虚函数的区别

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

### 为什么析构函数必须是虚函数；为什么C++默认的析构函数不是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 请问C++中拷贝赋值函数的形参能否进行值传递

不能，因为如果要进行值传递，这又得调用拷贝赋值函数，也就是依赖于其本身，这就会产生一个无限循环，无法完成拷贝，栈也会满

## 内存分配/编译/底层

### 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么

malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。

malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统调用brk在堆区中分配；而当申请内存大于128K时，会使用系统调用mmap在映射区分配。

### new/delete与malloc/free的区别是什么

new/delete是C++的操作符，可以重载，而malloc/free是C语言的库函数，不能重载（C不支持重载）

malloc需要给定申请内存的大小，返回的是void*，一般需要强制类型转化；new会调用构造函数，不用指定内存大小，返回的指针不用强转。

malloc失败返回空，new失败抛异常

malloc分配的内存不够时，可以使用realloc扩容，而new没有这种操作

free会释放内存空间，对于类类型的对象，不会调用析构函数；delete也会释放内存空间，对于类类型对象会执行析构函数

申请数组时，`new[]`一次分配所有内存，多次调用构造函数，搭配使用`delete[]`，`delete[]`多次调用析构函数，销毁数组中的每个对象，而malloc只能接收类似`sizeof(int)*n`这样的参数形式来开辟能容纳n个int型元素的数组空间

### C++中delete和delete[]的区别是什么

delete操作符释放空间，而且会调用由new创建的单个对象的析构函数

`delete[]`操作符释放空间，而且会调用由`new[]`创建的一组对象的析构函数

由`new[]`创建的内存空间，如果由delete释放，则编译器只会释放第一个对象的内存空间，后面的内存空间没法释放，于是产生内存泄漏

编译器怎么知道`delete[]`要销毁多少个对象呢，关键在于`new[]`时会把instance的数量存在开头，编译器遇到`delete[]`时就会寻找这个字段值，所以建议：用delete删除new的空间，用`delete[]`删除`new[]`的空间

### 什么是内存泄漏

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

C++内存泄漏分类：

1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

mtrace是用来检查内存泄露的C函数，其原理是记录每一对malloc和free，其他类型的内存泄漏没法找出

Valgrind是专门检查内存泄漏的工具，可以发现访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题，更为强大

### 什么是段错误

段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的（数组越界、类型不一致），要么是受到系统保护的（内核或其他程序正在使用）。

### C++内存分配（管理）方式

[C++ 自由存储区是否等价于堆？](https://www.cnblogs.com/qg-whz/p/5060894.html)

栈：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。操作方式类似于数据结构里的栈。向下增长。

堆：malloc在堆上分配的内存块，使用free释放内存。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。操作方式类似于数据结构里的链表。向上增长。可以说堆是操作系统维护的一块内存（物理上的）。

自由存储区：new所申请的内存则是在自由存储区上，使用delete来释放。自由存储区是C++通过new与delete动态分配和释放对象的抽象概念（逻辑上的），有可能是由堆实现的，可以说new所申请的内存在堆上

全局/静态存储区，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

常量存储区，存放常量，不建议修改，程序结束后由系统释放。

### 如何进行函数调用，参数压栈顺序是怎样的，返回

函数调用时，依次把参数压栈，栈的增长由高地址往低地址的方向，调用前，先把返回地址压入栈，这样执行完函数之后，弹出即可获得返回地址

函数参数入栈顺序为从右到左。

### C++源文件从文本到可执行文件经历的过程

一般需要四个过程：

1. 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
2. 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
3. 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
4. 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

### include头文件的顺序

对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。

google C++编程风格的建议，为了加强可读性和避免隐含依赖，应使用下面的顺序：C标准库、C++标准库、其它库的头文件、你自己工程的头文件。不过这里最先包含的是首选的头文件，即例如a.cpp文件中应该优先包含a.h。首选的头文件是为了减少隐藏依赖，同时确保头文件和实现文件是匹配的

### include头文件双引号""和尖括号<>的区别

编译器预处理阶段查找头文件的路径不一样。

对于双引号：当前头文件目录、编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

对于尖括号：编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

## STL

### STL有什么内容

空间分配器、迭代器、容器、泛型算法、仿函数、配接器

分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

### 介绍一下STL的allocator

allocator是C++中的空间配置器，用于封装STL容器在内存管理上的底层细节，注意不是内存配置器，因为内存是空间的一部分。

其内存配置和释放如下：new运算分两个阶段：(1)调用new操作符配置内存;(2)调用对象构造函数构造对象内容。delete运算分两个阶段：(1)调用对象希构函数；(2)调用delete操作符释放内存

同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128 bytes时，会使用第一级空间配置器；当分配的空间大小小于128 Bytes时，将使用第二级空间配置器。

第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放。

而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存，初始配置一大块内存，并维护对应不同内存空间大小的的16个空闲链表，如果有内存需求，直接在空闲链表中取，如果有内存释放，则归还到空闲链表中。

### 迭代器和指针的区别/有了指针为什么还要迭代器

迭代器不是指针，是类模板，内部封装了指针，相当于一种智能指针，是指针概念的一种提升。

迭代器重载了指针的一些操作符，->、*、++、--等，提供了比指针更高级的行为，它可以根据不同类型的数据结构来实现不同的++，--等操作。

iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

注意：迭代器的解引用操作返回的是对象引用而不是对象的值

### STL迭代器失效总结

vector

1. 插入（push_back）一个元素后，插入前end()操作返回的迭代器肯定失效，常见的错误做法如下：

    ```c++
    auto end = vec.end();
    for(it = vec.begin(); it != end; ++it){
        vec.push(back(0));
    }
    ```

2. 插入一个元素，有可能vector的capacity发生了变化（这里牵涉到vectora的动态扩容），那么原来所有的迭代器都失效

3. 当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。一般可以利用erase()的返回值得到删除点后面的那个元素

    ```c++
    vector<int> vec = {0,1,2,3};
    auto it = vec.begin();
    it = vec.erase(it); // now it points to 1
    ```

list

1. 插入（insert）和接合（splice）都不会使原有的list迭代器失效，链表只需要改变指针就好，内存没有发生变化，所以迭代器也不会失效
2. 删除操作（erase）也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。

deque

1. 在队前或队后插入元素时（push_back(),push_front()）,由于可能缓冲区的空间不够，需要增加map中控器，而中控器的个数也不够，所以新开辟更大的空间来容纳中控器，而deque迭代器中有四个指针，分别指向当前节点、当前缓冲区头、当前缓冲区尾、中控器，指向中控器的那个指针肯定失效了，所以deque迭代器也会失效！但是指针和引用不会失效，因为缓冲区已有的元素并没有重新分配内存！
2. 其他位置插入元素时，由于会造成缓冲区的一些元素的移动（源码中执行copy()来移动数据），所以肯定会造成迭代器的失效
3. 删除队头或队尾的元素时，由于只是对当前的元素进行操作，所以其他元素的迭代器不会受到影响，所以一定不会失效，而且指针和引用也都不会失效；
4. 删除其他位置的元素时，也会造成元素的移动，所以其他元素的迭代器、指针和引用都会失效。

queue和stack严格来说是容器适配器，底层用的容器还是deque，又因为它们不提供遍历行为，所以压根就没有迭代器！

priority_queue是用堆（heap）实现的，只有最顶端的元素才有机会被外界使用，所以不提供遍历行为，所以压根就没有迭代器！

set和map底层是以红黑树结构来实现的，而父子节点的连接只需要指针就好了，插入一个元素不会使任何迭代器失效，删除当前的迭代器，仅仅会使当前的迭代器失效，但是erase()操作返回值是void，所以想要遍历的话只能通过erase(iter++)实现

unordered_set和unordered_map底层是用哈希表实现的，而一般哈希表是用开链法解决哈希冲突的，即散列到同一个bucket/slot上的元素，通过链表连接起来，所以这两个容器的迭代器，插入不影响其他迭代器，删除只影响删除节点的迭代器；但有一个例外，如果哈希表中元素过多，需要再散列（rehashing），所有原来的迭代器都会失效

### vector的resize和reserve的区别

resize(size_type n)：改变当前容器内含有元素的数量，后面可以用vec.size()获取n。如果原来vec.size()小于n，那么容器会新增（n-原size）个元素，新元素调用默认构造函数（该函数也可接受第二个参数用来确定新增元素的初始值）；如果原来vec.size()大于n，则会删除n之后的所有元素。

reserve(size_type n)：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；

## 操作系统与网络编程

### 请你说一下进程与线程的概念、区别

进程（process）是运行程序的一个实例，是程序运行的所有资源的总和，是操作系统进行资源调度和分配的最小单位。

线程（thread）是轻量级的进程，每个线程完成不同的任务，但是共享同一地址空间和全局变量，是CPU调度的最小单位

区别：

1. 一个线程只能属于一个进程，而一个进程可以至少有一个线程，可以有多个线程。线程依赖于进程而存在
2. 进程在执行过程中拥有独立的内存单元，资源分配给进程，同一进程的所有线程共享该进程的所有资源，包括地址空间、代码段（代码和常量）、数据段（全局变量和静态变量）、扩展段（堆存储），但是每个线程拥有自己的栈段，用来存放局部变量和临时变量
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位
4. 系统开销：创建或销毁进程时，系统要为之分配或回收资源，因此开销比线程更大；类似地，进程切换涉及到整个进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，所以进程切换的开销也远大于线程切换的开销。
5. 通信：由于同一进程中的多个线程具有相同的地址空间，所以它们之间的同步和通信的实现也变得比较容易
6. 进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉

### 有了进程为什么还有线程

并行实体共享同一个地址空间和所有可用数据的能力

线程比进程更轻量级，所以它们比进程更容易、更快创建，也更容易撤销

拥有多个线程允许这样活动彼此重叠进行，从而会加快应用程序执行速度

### 进程间通信

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

1. 管道：包括匿名管道和有名管道，匿名管道只能用于具有亲缘关系的父子进程间的通信，有名管道还允许无亲缘关系进程间的通信
2. 消息队列：消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
3. 信号量：它是一个计数器，可以用来控制多个进程对共享资源的访问，主要用于实现进程间的互斥与同步，而不是用于存储进程间通信数据
4. 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。主要作为进程间以及同一进程不同线程之间的同步手段。
5. 共享内存（最快的）：多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等
6. 套接字socket：可用于不同机器间的进程通信

### 线程间通信/线程间的同步方式

因为线程共享同一地址空间，所以线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

各个线程可以访问进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。

1. 锁机制：包括互斥锁、条件变量、读写锁
    - 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
    - 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
    - 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
2. 信号量机制：包括无名线程信号量和命名线程信号量
3. 信号机制：类似进程间的信号处理

### Linux虚拟地址空间

### 缺页中断是怎么回事

缺页中断指的是当进程试图访问已映射在虚拟地址空间，但并未被加载在物理内存中的一个分页时，由CPU所触发的中断。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：

1. 保护CPU现场
2. 分析中断原因
3. 转入缺页中断处理程序进行处理
4. 恢复CPU现场，继续执行

区别在于：

1. 在指令执行期间产生和处理缺页中断信号
2. 一条指令在执行期间，可能产生多次缺页中断
3. 缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令

### 页面置换算法有哪些，优缺点是什么

如果发生缺页中断，为了能够把所缺的页面装入内存，系统必须从内存中选择一页将其换出，选择哪个页面调出就取决于页面置换算法。如果一个被频繁使用地页面被置换出内存，那么它很快又要被调入内存，这就造成了不必要的开销，所以一个好的页面置换算法至关重要。

PS：如果要换出的页面在驻留内存期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本，如果该页面没有被修改过，那么就不需要写回磁盘，

1. 最佳/最优置换（Optimal）：被置换的页面以后不再被访问，或者在将来最迟才回被访问的页面，缺页中断率最低，这是不切实际的，但仍可以作为衡量其他页面置换算法的标准
2. 先进先出置换（FIFO）：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面，一般按照进入内存的先后次序排列成队列，但是该算法会淘汰经常访问的页面，不适合进程实际运行规律，很少使用纯粹的FIFO置换算法
3. 最近最少使用置换（Least Recently Used, LRU）：置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。LRU置换算法效率不粗破，适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU置换算法必须要有硬件的支持
4. 时钟页面置换算法（clock）：现实的
5. 最近未使用（NRU）：LRU的很粗糙的近似
6. 最不经常使用（NFU）：LRU的相对粗略近似
7. 老化算法：非常近似LRU的有效算法
8. 工作集算法：开销很大
9. 工作集时钟算法：好的有效算法

### 说一说fork,wait,exec函数

父进程使用fork拷贝出来一个父进程的副本，只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，

exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。

fork从父进程返回子进程的pid，从子进程返回0.

调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。

exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

### 同步和异步以及阻塞和非阻塞

要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？

举一个例子来说明上面的概念，小明去买自己爱吃的烧鸡

- 同步阻塞的做法是小明付帐后一直盯着老板制作烧鸡，直到完成才高兴的办其它事了。
- 同步非阻塞的做法是小明付帐后不会一直盯着老板，而是做其它事了，每隔一会来看看老板做好了没。
- 异步阻塞的做法是小明付帐以后，不会盯着老板做了，也不干其它事，老板做好了通知小明。
- 异步非阻塞指的是小明付帐以后，干自己的事去了，老板做好了通知小明。

同步和异步的本质是我轮询你还是你回调我；阻塞和非阻塞的本质是当发生等待的时候我能不能干其它的事

### 如何采用单线程的方式处理高并发

可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件

### Unix五种I/O模型

1. 阻塞式I/O模型：最流行，默认情况下套接字都是该模型
2. 非阻塞式I/O模型：通知内核，轮询，耗费大量CPU时间，一般是专门提供某一种功能的系统才用
3. I/O复用（select、poll）：进程阻塞在select系统调用上，直到数据可读，系统调用recvfrom，优势在于等待多个描述符就绪
4. 信号驱动I/O模型：在描述符就绪时发送SIGIO信号通知我们，该模型优势是在等待数据报到达期间进程不阻塞
5. 异步I/O模型：POSIX规范定义的。告知内核启动某操作，并让内核在整个操作（包括数据从内核复制到进程缓冲区）完成才通知我们。

异步I/O模型与信号驱动I/O主要区别是：前者是内核通知我们何时启动一个I/O操作，而后者是由内核通知何时I/O操作完成，信号在操作完成才产生。

前四种都是同步的，因为真正的I/O操作会阻塞进程；第五种是异步的。

### 请你来说一下reactor模型

网络框架大多数都是基于Reactor模式进行设计和开发，Reactor模式基于事件驱动，特别适合处理海量的I/O事件

reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成

### 请你说一说epoll原理

调用顺序：
int epoll_create(int size);

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);

首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。

### select呢